---
title: 'Index Syntax | Reference'
description: ''
---

# 인덱스 구문

Move는 네이티브 Move 코드처럼 보이고 느껴지는 연산을 정의할 수 있도록 구문 속성을 제공하며, 이러한 연산을 사용자가 제공한 정의로 변환합니다.

첫 번째 구문 메서드인 `index`를 사용하면 이러한 인덱스 연산에 사용되어야 하는 함수에 주석을 달아서 `m[i,j]`와 같이 행렬 요소에 접근하는 것과 같은 데이터 타입에 대한 사용자 정의 인덱스 접근자로 사용할 수 있는 연산 그룹을 정의할 수 있습니다. 또한 이러한 정의는 타입별로 맞춤화되며 해당 타입을 사용하는 모든 프로그래머가 암시적으로 사용할 수 있습니다.

## 개요 및 요약

먼저 벡터의 벡터를 사용하여 값을 나타내는 `Matrix` 타입을 고려해보세요. 다음과 같이 `borrow` 및 `borrow_mut` 함수에 `index` 구문 주석을 사용하여 작은 라이브러리를 작성할 수 있습니다:

```move
module matrix::matrix;

public struct Matrix<T> { v: vector<vector<T>> }

#[syntax(index)]
public fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {
    vector::borrow(vector::borrow(&s.v, i), j)
}

#[syntax(index)]
public fun borrow_mut<T>(s: &mut Matrix<T>, i: u64, j: u64): &mut T {
    vector::borrow_mut(vector::borrow_mut(&mut s.v, i), j)
}

public fun make_matrix<T>(v: vector<vector<T>>):  Matrix<T> {
    Matrix { v }
}
```

이제 이 `Matrix` 타입을 사용하는 누구나 인덱스 구문에 접근할 수 있습니다:

```move
let mut m = matrix::make_matrix(vector[
    vector[1, 0, 0],
    vector[0, 1, 0],
    vector[0, 0, 1],
]);x

let mut i = 0;
while (i < 3) {
    let mut j = 0;
    while (j < 3) {
        if (i == j) {
            assert!(m[i, j] == 1, 1);
        } else {
            assert!(m[i, j] == 0, 0);
        };
        *(&mut m[i,j]) = 2;
        j = j + 1;
    };
    i = i + 1;
}
```

## 사용법

예제에서 보듯이, 데이터 타입과 관련된 인덱스 구문 메서드를 정의하면 누구나 해당 타입의 값에 대해 인덱스 구문을 작성하여 해당 메서드를 호출할 수 있습니다:

```move
let mat = matrix::make_matrix(...);
let m_0_0 = mat[0, 0];
```

컴파일 중에 컴파일러는 표현식의 위치와 가변 사용법을 기반으로 이를 적절한 함수 호출로 변환합니다:

````move
let mut mat = matrix::make_matrix(...);

let m_0_0 = mat[0, 0];
// translates to `copy matrix::borrow(&mat, 0, 0)`

let m_0_0 = &mat[0, 0];
// translates to `matrix::borrow(&mat, 0, 0)`

let m_0_0 = &mut mat[0, 0];
// translates to `matrix::borrow_mut(&mut mat, 0, 0)`
``

인덱스 표현식을 필드 접근과 혼합하여 사용할 수도 있습니다:

```move
public struct V { v: vector<u64> }

public struct Vs { vs: vector<V> }

fun borrow_first(input: &Vs): &u64 {
    &input.vs[0].v[0]
    // translates to `vector::borrow(&vector::borrow(&input.vs, 0).v, 0)`
}
````

### 인덱스 함수는 유연한 인자를 받습니다

이 장의 나머지 부분에서 설명하는 정의 및 타입 제한 사항을 제외하고, Move는 인덱스 구문 메서드가 매개변수로 받는 값에 제한을 두지 않습니다. 이를 통해 인덱스가 범위를 벗어날 경우 기본값을 취하는 데이터 구조와 같이 인덱스 구문을 정의할 때 복잡한 프로그래밍 동작을 구현할 수 있습니다:

```move
#[syntax(index)]
public fun borrow_or_set<Key: copy, Value: drop>(
    input: &mut MTable<Key, Value>,
    key: Key,
    default: Value
): &mut Value {
    if (contains(input, key)) {
        borrow(input, key)
    } else {
        insert(input, key, default);
        borrow(input, key)
    }
}
```

이제 `MTable`에 인덱싱할 때 기본값도 제공해야 합니다:

```move
let string_key: String = ...;
let mut table: MTable<String, u64> = m_table::make_table();
let entry: &mut u64 = &mut table[string_key, 0];
```

이러한 확장 가능한 기능을 통해 타입에 대한 정확한 인덱스 인터페이스를 작성하여 맞춤형 동작을 구체적으로 적용할 수 있습니다.

## 인덱스 구문 함수 정의하기

이 강력한 구문 형식을 사용하면 다음 규칙을 준수한다는 가정 하에 모든 사용자 정의 데이터 타입이 이러한 방식으로 동작할 수 있습니다:

1. `#[syntax(index)]` 속성이 대상 타입과 동일한 모듈에 정의된 지정된 함수에 추가됩니다.
1. 지정된 함수는 `public` 가시성을 가집니다.
1. 함수는 대상 타입(첫 번째 인자)으로 참조 타입을 받고 일치하는 참조 타입(`mut`인 경우 `mut`)을 반환합니다.
1. 각 타입은 하나의 가변 정의와 하나의 불변 정의만 가집니다.
1. 불변 및 가변 버전은 타입 일치성을 가집니다:
   - 대상 타입은 가변성만 다르고 일치합니다.
   - 반환 타입은 대상 타입의 가변성과 일치합니다.
   - 타입 매개변수가 있는 경우 두 버전 간에 동일한 제약 조건을 가집니다.
   - 대상 타입 이후의 모든 매개변수는 동일합니다.

다음 내용과 추가 예제는 이러한 규칙을 더 자세히 설명합니다.

### 선언

인덱스 구문 메서드를 선언하려면 대상 타입 정의와 동일한 모듈의 관련 함수 정의 위에 `#[syntax(index)]` 속성을 추가합니다. 이는 컴파일러에게 해당 함수가 지정된 타입에 대한 인덱스 접근자임을 알립니다.

#### 불변 접근자

불변 인덱스 구문 메서드는 읽기 전용 접근을 위해 정의됩니다. 대상 타입의 불변 참조를 받아 요소 타입에 대한 불변 참조를 반환합니다. `std::vector`에 정의된 `borrow` 함수가 이러한 예입니다:

```move
#[syntax(index)]
public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
```

#### 가변 접근자

가변 인덱스 구문 메서드는 불변 메서드의 쌍으로, 읽기와 쓰기 작업 모두를 허용합니다. 대상 타입의 가변 참조를 받아 요소 타입에 대한 가변 참조를 반환합니다. `std::vector`에 정의된 `borrow_mut` 함수가 이러한 예입니다:

```move
#[syntax(index)]
public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
```

#### 가시성

타입이 사용되는 모든 곳에서 인덱싱 함수를 사용할 수 있도록 하기 위해 모든 인덱스 구문 메서드는 public 가시성을 가져야 합니다. 이는 Move의 모듈과 패키지 전반에서 인덱싱의 인체공학적 사용을 보장합니다.

#### 중복 금지

위의 요구 사항 외에도 각 대상 기본 타입이 불변 참조에 대한 단일 인덱스 구문 메서드와 가변 참조에 대한 단일 인덱스 구문 메서드를 정의하도록 제한합니다. 예를 들어, 다형성 타입에 대한 특수화된 버전을 정의할 수 없습니다:

```move
#[syntax(index)]
public fun borrow_matrix_u64(s: &Matrix<u64>, i: u64, j: u64): &u64 { ... }

#[syntax(index)]
public fun borrow_matrix<T>(s: &Matrix<T>, i: u64, j: u64): &T { ... }
    // ERROR! Matrix already has a definition
    // for its immutable index syntax method
```

이는 타입 인스턴스화를 검사할 필요 없이 항상 어떤 메서드가 호출되는지 알 수 있도록 보장합니다.

### 타입 제약 조건

기본적으로 인덱스 구문 메서드는 다음과 같은 타입 제약 조건을 가집니다:

**대상 타입(첫 번째 인자)은 표시된 함수와 동일한 모듈에 정의된 단일 타입에 대한 참조여야 합니다.** 이는 튜플, 타입 매개변수 또는 값에 대한 인덱스 구문 메서드를 정의할 수 없음을 의미합니다:

```move
#[syntax(index)]
public fun borrow_fst(x: &(u64, u64), ...): &u64 { ... }
    // ERROR because the subject type is a tuple

#[syntax(index)]
public fun borrow_tyarg<T>(x: &T, ...): &T { ... }
    // ERROR because the subject type is a type parameter

#[syntax(index)]
public fun borrow_value(x: Matrix<u64>, ...): &u64 { ... }
    // ERROR because x is not a reference
```

**대상 타입은 반환 타입과 가변성이 일치해야 합니다.** 이 제한을 통해 `&vec[i]`와 `&mut vec[i]`로 인덱싱된 표현식을 차용할 때 예상되는 동작을 명확히 할 수 있습니다. Move 컴파일러는 가변성 표시를 사용하여 적절한 가변성의 참조를 생성하기 위해 호출할 차용 형식을 결정합니다. 결과적으로 대상과 반환 가변성이 다른 인덱스 구문 메서드는 허용하지 않습니다:

```move
#[syntax(index)]
public fun borrow_imm(x: &mut Matrix<u64>, ...): &u64 { ... }
    // ERROR! incompatible mutability
    // expected a mutable reference '&mut' return type
```

### 타입 호환성

불변 및 가변 인덱스 구문 메서드 쌍을 정의할 때 여러 호환성 제약 조건이 적용됩니다:

1. 동일한 수의 타입 매개변수를 가져야 하고, 해당 타입 매개변수는 동일한 제약 조건을 가져야 합니다.
1. 타입 매개변수는 이름이 아닌 _위치별로_ 동일하게 사용되어야 합니다.
1. 대상 타입은 가변성을 제외하고 정확히 일치해야 합니다.
1. 반환 타입은 가변성을 제외하고 정확히 일치해야 합니다.
1. 다른 모든 매개변수 타입은 정확히 일치해야 합니다.

이러한 제약 조건은 인덱스 구문이 가변 또는 불변 위치에 관계없이 동일하게 동작하도록 보장합니다.

이러한 오류 중 일부를 설명하기 위해 이전 `Matrix` 정의를 다시 살펴보겠습니다:

```move
#[syntax(index)]
public fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {
    vector::borrow(vector::borrow(&s.v, i), j)
}
```

다음은 모두 가변 버전의 타입 호환되지 않는 정의입니다:

```move
#[syntax(index)]
public fun borrow_mut<T: drop>(s: &mut Matrix<T>, i: u64, j: u64): &mut T { ... }
    // ERROR! `T` has `drop` here, but no in the immutable version

#[syntax(index)]
public fun borrow_mut(s: &mut Matrix<u64>, i: u64, j: u64): &mut u64 { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut<T, U>(s: &mut Matrix<U>, i: u64, j: u64): &mut U { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut<U>(s: &mut Matrix<U>, i_j: (u64, u64)): &mut U { ... }
    // ERROR! This takes a different number of arguments

#[syntax(index)]
public fun borrow_mut<U>(s: &mut Matrix<U>, i: u64, j: u32): &mut U { ... }
    // ERROR! `j` is a different type
```

다시 말해, 여기서의 목표는 불변 및 가변 버전 전반에 걸쳐 사용법을 일관되게 만드는 것입니다. 이를 통해 인덱스 구문 메서드가 가변 대 불변 사용법에 따라 동작이나 제약 조건을 변경하지 않고 작동할 수 있으며, 궁극적으로 프로그래밍할 때 일관된 인터페이스를 보장합니다.
