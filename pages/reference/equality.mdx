---
title: 'Equality | Reference'
description: ''
---

# 동등성

Move는 두 가지 동등성 연산 `==`와 `!=`를 지원합니다

## 연산

| 구문 | 연산 | 설명                                                                 |
| ------ | --------- | --------------------------------------------------------------------------- |
| `==`   | 같음     | 두 피연산자가 같은 값을 가지면 `true`를 반환하고, 그렇지 않으면 `false`를 반환   |
| `!=`   | 같지 않음 | 두 피연산자가 다른 값을 가지면 `true`를 반환하고, 그렇지 않으면 `false`를 반환 |

### 타이핑

같음(`==`)과 같지 않음(`!=`) 연산은 모두 두 피연산자가 같은 타입일 때만 작동합니다

```move
0 == 0; // `true`
1u128 == 2u128; // `false`
b"hello" != x"00"; // `true`
```

동등성과 비동등성은 _모든_ 사용자 정의 타입에서도 작동합니다!

```move
module 0::example;

public struct S has copy, drop { f: u64, s: vector<u8> }

fun always_true(): bool {
    let s = S { f: 0, s: b"" };
    s == s
}

fun always_false(): bool {
    let s = S { f: 0, s: b"" };
    s != s
}
```

피연산자가 다른 타입을 가지면 타입 검사 오류가 발생합니다

```move
1u8 == 1u128; // 오류!
//     ^^^^^ 'u8' 타입의 인자가 예상됩니다
b"" != 0; // 오류!
//     ^ 'vector<u8>' 타입의 인자가 예상됩니다
```

### 참조를 사용한 타이핑

[참조](./primitive-types/references)를 비교할 때, 참조의 타입(불변 또는 가변)은 중요하지 않습니다. 즉, 동일한 기본 타입의 불변 `&` 참조와 가변 `&mut` 참조를 비교할 수 있습니다.

```move
let i = &0;
let m = &mut 1;

i == m; // `false`
m == i; // `false`
m == m; // `true`
i == i; // `true`
```

위의 코드는 필요한 곳에서 각 가변 참조에 명시적 freeze를 적용하는 것과 동일합니다

```move
let i = &0;
let m = &mut 1;

i == freeze(m); // `false`
freeze(m) == i; // `false`
m == m; // `true`
i == i; // `true`
```

하지만 다시 말해, 기본 타입은 같은 타입이어야 합니다

```move
let i = &0;
let s = &b"";

i == s; // 오류!
//   ^ '&u64' 타입의 인자가 예상됩니다
```

### 자동 차용

Move 2024 에디션부터 `==`와 `!=` 연산자는 피연산자 중 하나가 참조이고 다른 하나가 참조가 아닌 경우 피연산자를 자동으로 차용합니다. 이는 다음 코드가 오류 없이 작동한다는 것을 의미합니다:

```move
let r = &0;

// 모든 경우에 `0`은 자동으로 `&0`으로 차용됩니다
r == 0; // `true`
0 == r; // `true`
r != 0; // `false`
0 != r; // `false`
```

이 자동 차용은 항상 불변 차용입니다.

## 제한 사항

`==`와 `!=` 모두 값을 비교할 때 해당 값을 소비합니다. 결과적으로, 타입 시스템은 타입이 [`drop`](./abilities)을 가져야 한다고 강제합니다. [`drop` ability](./abilities) 없이는 소유권이 함수 끝까지 전송되어야 하고, 그러한 값은 선언된 module 내에서만 명시적으로 파괴될 수 있다는 것을 기억하세요. 이러한 값이 동등성 `==` 또는 비동등성 `!=`와 직접 사용되면, 값이 파괴되어 [`drop` ability](./abilities) 안전성 보장을 깨뜨릴 것입니다!

```move
module 0::example;

public struct Coin has store { value: u64 }
fun invalid(c1: Coin, c2: Coin) {
    c1 == c2 // 오류!
//  ^^    ^^ 이러한 자산들이 파괴됩니다!
}
```

하지만 프로그래머는 값을 직접 비교하는 대신 _항상_ 먼저 값을 차용할 수 있으며, 참조 타입은 [`drop` ability](./abilities)를 가집니다. 예를 들어

```move
module 0::example;

public struct Coin has store { value: u64 }
fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
    let are_equal = &c1 == c2; // 유효함, `c2`는 자동으로 차용됩니다
    if (are_equal) (c2, c1) else (c1, c2)
}
```

## 추가 복사 피하기

프로그래머는 [`drop`](./abilities)을 가진 타입의 모든 값을 비교_할 수_ 있지만, 비싼 복사를 피하기 위해 종종 참조로 비교해야 합니다.

```move
let v1: vector<u8> = function_that_returns_vector();
let v2: vector<u8> = function_that_returns_vector();
assert!(copy v1 == copy v2, 42);
//      ^^^^       ^^^^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(copy s1 == copy s2, 42);
//      ^^^^       ^^^^
use_two_foos(s1, s2);
```

이 코드는 완벽하게 허용됩니다(`Foo`가 [`drop`](./abilities)을 가진다고 가정하면). 단지 효율적이지 않을 뿐입니다.
강조된 복사는 제거되고 차용으로 대체될 수 있습니다

```move
let v1: vector<u8> = function_that_returns_vector();
let v2: vector<u8> = function_that_returns_vector();
assert!(&v1 == &v2, 42);
//      ^      ^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(&s1 == &s2, 42);
//      ^      ^
use_two_foos(s1, s2);
```

`==` 자체의 효율성은 동일하게 유지되지만, `copy`가 제거되어 프로그램이 더 효율적입니다.