---
title: '구조체 | Reference'
description: ''
---

# 구조체와 리소스

_구조체_는 타입이 지정된 필드를 포함하는 사용자 정의 데이터 구조입니다. 구조체는 다른 구조체를 포함하여 참조나 튜플이 아닌 모든 타입을 저장할 수 있습니다.

구조체는 모든 "자산" 값이나 제한되지 않은 값을 정의하는 데 사용할 수 있으며, 이러한 값에 대해 수행되는 작업은 구조체의 [ability](./abilities)로 제어할 수 있습니다. 기본적으로 구조체는 선형적(linear)이고 일시적(ephemeral)입니다. 즉, 복사할 수 없고, 삭제할 수 없으며, 스토리지에 저장할 수 없습니다. 이는 모든 값이 소유권을 이전해야 하고(선형적), 프로그램 실행이 끝날 때까지 값을 처리해야 한다는(일시적) 것을 의미합니다. 값을 복사하거나 삭제할 수 있도록 하고, 스토리지에 저장하거나 스토리지 스키마를 정의할 수 있도록 하는 [ability](./abilities)를 구조체에 부여하여 이러한 동작을 완화할 수 있습니다.

## 구조체 정의하기

구조체는 module 내부에서 정의되어야 하며, 구조체의 필드는 이름이 있거나 위치 기반일 수 있습니다:

```move
module a::m;

public struct Foo { x: u64, y: bool }
public struct Bar {}
public struct Baz { foo: Foo, }
//                          ^ 참고: 끝에 쉼표가 있어도 괜찮습니다

public struct PosFoo(u64, bool)
public struct PosBar()
public struct PosBaz(Foo)
```

구조체는 재귀적일 수 없으므로 다음 정의들은 유효하지 않습니다:

```move
public struct Foo { x: Foo }
//                     ^ 오류! 재귀적 정의

public struct A { b: B }
public struct B { a: A }
//                   ^ 오류! 재귀적 정의

public struct D(D)
//              ^ 오류! 재귀적 정의
```

### 가시성

여러분이 눈치채셨을 수도 있듯이, 모든 구조체는 `public`으로 선언됩니다. 이는 구조체의 타입을 다른 module에서 참조할 수 있다는 것을 의미합니다. 그러나 구조체의 필드와 구조체를 생성하거나 소멸시키는 기능은 여전히 구조체를 정의한 module 내부에서만 가능합니다.

향후 [함수](./functions#visibility)처럼 구조체를 `public(package)`나 internal로 선언하는 기능을 추가할 계획입니다.

### Abilities

위에서 언급했듯이: 기본적으로 구조체 선언은 선형적이고 일시적입니다. 따라서 값을 이러한 방식으로 사용할 수 있도록 하려면(예: 복사, 삭제, [object](./abilities/object)에 저장, 또는 저장 가능한 [object](./abilities/object) 정의에 사용), 구조체에 `has <ability>`로 주석을 달아 [ability](./abilities)를 부여할 수 있습니다:

```move
module a::m {
    public struct Foo has copy, drop { x: u64, y: bool }
}
```

ability 선언은 구조체의 필드 앞이나 뒤에 올 수 있습니다. 그러나 둘 중 하나만 사용할 수 있고, 둘 다 사용할 수는 없습니다. 구조체의 필드 뒤에 선언하는 경우, ability 선언은 세미콜론으로 끝나야 합니다:

```move
module a::m;

public struct PreNamedAbilities has copy, drop { x: u64, y: bool }
public struct PostNamedAbilities { x: u64, y: bool } has copy, drop;
public struct PostNamedAbilitiesInvalid { x: u64, y: bool } has copy, drop
//                                                                        ^ 오류! 세미콜론 누락

public struct NamedInvalidAbilities has copy { x: u64, y: bool } has drop;
//                                                               ^ 오류! 중복된 ability 선언

public struct PrePositionalAbilities has copy, drop (u64, bool)
public struct PostPositionalAbilities (u64, bool) has copy, drop;
public struct PostPositionalAbilitiesInvalid (u64, bool) has copy, drop
//                                                                     ^ 오류! 세미콜론 누락
public struct InvalidAbilities has copy (u64, bool) has drop;
//                                                  ^ 오류! 중복된 ability 선언
```

자세한 내용은 [구조체의 ability 주석 달기](./abilities#annotating-structs-and-enums) 섹션을 참조하세요.

### 명명 규칙

구조체는 대문자 `A`부터 `Z`로 시작해야 합니다. 첫 글자 이후에는 구조체 이름에 밑줄 `_`, 소문자 `a`부터 `z`, 대문자 `A`부터 `Z`, 또는 숫자 `0`부터 `9`를 포함할 수 있습니다.

```move
public struct Foo {}
public struct BAR {}
public struct B_a_z_4_2 {}
public struct P_o_s_Foo()
```

`A`부터 `Z`로 시작해야 한다는 이 명명 제한은 향후 언어 기능을 위한 여유 공간을 제공하기 위한 것입니다. 나중에 제거될 수도 있고 그렇지 않을 수도 있습니다.

## 구조체 사용하기

### 구조체 생성하기

구조체 타입의 값은 구조체 이름을 지정하고 각 필드에 대한 값을 제공하여 생성("패킹")할 수 있습니다.

이름이 있는 필드를 가진 구조체의 경우, 필드의 순서는 중요하지 않지만 필드 이름을 제공해야 합니다. 위치 기반 필드를 가진 구조체의 경우, 필드의 순서가 구조체 정의의 필드 순서와 일치해야 하며, 매개변수를 감싸기 위해 `{}` 대신 `()`를 사용하여 생성해야 합니다.

```move
module a::m;

public struct Foo has drop { x: u64, y: bool }
public struct Baz has drop { foo: Foo }
public struct Positional(u64, bool) has drop;

fun example() {
    let foo = Foo { x: 0, y: false };
    let baz = Baz { foo: foo };
    // 참고: 위치 기반 구조체 값은 이름 대신 위치를 기반으로
    // 괄호를 사용하여 생성됩니다.
    let pos = Positional(0, false);
    let pos_invalid = Positional(false, 0);
    //                           ^ 오류! 필드 순서가 잘못되었고 타입이 일치하지 않습니다.
}
```

이름이 있는 필드를 가진 구조체의 경우, 필드와 동일한 이름의 로컬 변수가 있다면 다음과 같은 축약형을 사용할 수 있습니다:

```move
let baz = Baz { foo: foo };
// 다음과 동일합니다
let baz = Baz { foo };
```

이를 때때로 "필드 이름 펀닝(field name punning)"이라고 합니다.

### 패턴 매칭을 통한 구조체 소멸

구조체 값은 생성할 때와 유사한 구문을 사용하여 패턴에서 바인딩하거나 할당하여 소멸시킬 수 있습니다.

```move
module a::m;

public struct Foo { x: u64, y: bool }
public struct Bar(Foo)
public struct Baz {}
public struct Qux()

fun example_destroy_foo() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y: foo_y } = foo;
    //        ^ `x: x`의 축약형

    // 두 개의 새로운 바인딩
    //   x: u64 = 3
    //   foo_y: bool = false
}

fun example_destroy_foo_wildcard() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y: _ } = foo;

    // y가 와일드카드에 바인딩되었으므로 하나의 새로운 바인딩만 생성됨
    //   x: u64 = 3
}

fun example_destroy_foo_assignment() {
    let x: u64;
    let y: bool;
    Foo { x, y } = Foo { x: 3, y: false };

    // 기존 변수 x와 y를 변경
    //   x = 3, y = false
}

fun example_foo_ref() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y } = &foo;

    // 두 개의 새로운 바인딩
    //   x: &u64
    //   y: &bool
}

fun example_foo_ref_mut() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y } = &mut foo;

    // 두 개의 새로운 바인딩
    //   x: &mut u64
    //   y: &mut bool
}

fun example_destroy_bar() {
    let bar = Bar(Foo { x: 3, y: false });
    let Bar(Foo { x, y }) = bar;
    //            ^ 중첩된 패턴

    // 두 개의 새로운 바인딩
    //   x: u64 = 3
    //   y: bool = false
}

fun example_destroy_baz() {
    let baz = Baz {};
    let Baz {} = baz;
}

fun example_destroy_qux() {
    let qux = Qux();
    let Qux() = qux;
}
```

### 구조체 필드 접근하기

구조체의 필드는 점 연산자 `.`를 사용하여 접근할 수 있습니다.

이름이 있는 필드를 가진 구조체의 경우, 필드는 이름으로 접근할 수 있습니다:

```move
public struct Foo { x: u64, y: bool }
let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
```

위치 기반 구조체의 경우, 필드는 구조체 정의에서의 위치로 접근할 수 있습니다:

```move
public struct PosFoo(u64, bool)
let pos_foo = PosFoo(3, true);
let x = pos_foo.0;  // x == 3
let y = pos_foo.1;  // y == true
```

빌림이나 복사 없이 구조체 필드에 접근하는 것은 필드의 ability 제약을 받습니다. 자세한 내용은 [구조체와 필드 빌리기](#borrowing-structs-and-fields)와 [필드 읽기 및 쓰기](#reading-and-writing-fields) 섹션을 참조하세요.

### 구조체와 필드 빌리기

`&`와 `&mut` 연산자를 사용하여 구조체나 필드에 대한 참조를 생성할 수 있습니다. 이 예제들은 작업의 타입을 보여주기 위해 일부 선택적 타입 주석(예: `: &Foo`)을 포함합니다.

```move
let foo = Foo { x: 3, y: true };
let foo_ref: &Foo = &foo;
let y: bool = foo_ref.y;         // 구조체에 대한 참조를 통해 필드 읽기
let x_ref: &u64 = &foo.x;        // 구조체에 대한 참조를 확장하여 필드 빌리기

let x_ref_mut: &mut u64 = &mut foo.x;
*x_ref_mut = 42;            // 가변 참조를 통해 필드 수정
```

중첩된 구조체의 내부 필드를 빌릴 수 있습니다:

```move
let foo = Foo { x: 3, y: true };
let bar = Bar(foo);

let x_ref = &bar.0.x;
```

구조체에 대한 참조를 통해 필드를 빌릴 수도 있습니다:

```move
let foo = Foo { x: 3, y: true };
let foo_ref = &foo;
let x_ref = &foo_ref.x;
// 이는 let x_ref = &foo.x와 동일한 효과를 가집니다
```

### 필드 읽기 및 쓰기

필드의 값을 읽고 복사해야 하는 경우, 빌린 필드를 역참조할 수 있습니다:

```move
let foo = Foo { x: 3, y: true };
let bar = Bar(copy foo);
let x: u64 = *&foo.x;
let y: bool = *&foo.y;
let foo2: Foo = *&bar.0;
```

더 표준적으로는, 점 연산자를 사용하여 빌림 없이 구조체의 필드를 읽을 수 있습니다. [역참조](./primitive-types/references#reading-and-writing-through-references)와 마찬가지로, 필드 타입은 `copy` [ability](./abilities)를 가져야 합니다.

```move
let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
```

점 연산자는 중첩된 필드에 접근하기 위해 연결할 수 있습니다:

```move
let bar = Bar(Foo { x: 3, y: true });
let x = baz.0.x; // x = 3;
```

그러나 벡터나 다른 구조체와 같은 비원시 타입을 포함하는 필드에는 이것이 허용되지 않습니다:

```move
let foo = Foo { x: 3, y: true };
let bar = Bar(foo);
let foo2: Foo = *&bar.0;
let foo3: Foo = bar.0; // 오류! *&로 명시적 복사를 추가해야 합니다
```

구조체의 필드를 가변으로 빌려서 새 값을 할당할 수 있습니다:

```move
let mut foo = Foo { x: 3, y: true };
*&mut foo.x = 42;     // foo = Foo { x: 42, y: true }
*&mut foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);               // bar = Bar(Foo { x: 42, y: false })
*&mut bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
*&mut bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
```

역참조와 유사하게, 대신 점 연산자를 직접 사용하여 필드를 수정할 수 있습니다. 두 경우 모두 필드 타입은 `drop` [ability](./abilities)를 가져야 합니다.

```move
let mut foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);         // bar = Bar(Foo { x: 42, y: false })
bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
```

할당을 위한 점 구문은 구조체에 대한 참조를 통해서도 작동합니다:

```move
let foo = Foo { x: 3, y: true };
let foo_ref = &mut foo;
foo_ref.x = foo_ref.x + 1;
```

## 특권 구조체 작업

구조체 타입 `T`에 대한 대부분의 구조체 작업은 `T`를 선언한 module 내부에서만 수행할 수 있습니다:

- 구조체 타입은 구조체를 정의한 module 내부에서만 생성("패킹"), 소멸("언패킹")할 수 있습니다.
- 구조체의 필드는 구조체를 정의한 module 내부에서만 접근할 수 있습니다.

이러한 규칙에 따라, module 외부에서 구조체를 수정하려면 public API를 제공해야 합니다. 장의 끝에 이에 대한 몇 가지 예제가 포함되어 있습니다.

그러나 [위의 가시성 섹션](#visibility)에서 설명한 대로, 구조체 _타입_은 항상 다른 module에서 볼 수 있습니다

```move
module a::m {
    public struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}

module a::n {
    use a::m::Foo;

    public struct Wrapper has drop {
        foo: Foo
        //   ^ 유효함, 타입이 public입니다

    }

    fun f1(foo: Foo) {
        let x = foo.x;
        //      ^ 오류! `a::m` 외부에서 `Foo`의 필드에 접근할 수 없습니다
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: m::new_foo() };
        //                               ^ 유효함, 함수가 public입니다
    }
}

```

## 소유권

[구조체 정의하기](#defining-structs)에서 언급했듯이, 구조체는 기본적으로 선형적이고 일시적입니다. 이는 복사하거나 삭제할 수 없다는 것을 의미합니다. 이 속성은 돈과 같은 실제 자산을 모델링할 때 매우 유용할 수 있습니다. 돈이 복제되거나 유통 중에 손실되는 것을 원하지 않기 때문입니다.

```move
module a::m;

public struct Foo { x: u64 }

public fun copying() {
    let foo = Foo { x: 100 };
    let foo_copy = copy foo; // 오류! 'copy'하려면 'copy' ability가 필요합니다
    let foo_ref = &foo;
    let another_copy = *foo_ref // 오류! 역참조하려면 'copy' ability가 필요합니다
}

public fun destroying_1() {
    let foo = Foo { x: 100 };

    // 오류! 함수가 반환될 때 foo가 여전히 값을 포함하고 있습니다.
    // 이 소멸에는 'drop' ability가 필요합니다
}

public fun destroying_2(f: &mut Foo) {
    *f = Foo { x: 100 } // 오류!
                        // 쓰기를 통해 이전 값을 소멸시키려면 'drop' ability가 필요합니다
}
```

`fun destroying_1` 예제를 수정하려면 값을 수동으로 "언패킹"해야 합니다:

```move
module a::m;

public struct Foo { x: u64 }

public fun destroying_1_fixed() {
    let foo = Foo { x: 100 };
    let Foo { x: _ } = foo;
}
```

구조체가 정의된 module 내에서만 구조체를 해체할 수 있다는 점을 기억하세요. 이를 활용하여 시스템에서 특정 불변성을 강제할 수 있습니다. 예를 들어, 돈의 보존성 같은 것입니다.

반면에, 구조체가 가치 있는 것을 나타내지 않는다면, `copy`와 `drop` ability를 추가하여 다른 프로그래밍 언어에서 더 친숙하게 느껴질 수 있는 구조체 값을 얻을 수 있습니다:

```move
module a::m;

public struct Foo has copy, drop { x: u64 }

public fun run() {
    let foo = Foo { x: 100 };
    let foo_copy = foo;
    //             ^ 이 코드는 foo를 복사합니다,
    //             반면 `let x = move foo`는 foo를 이동시킵니다

    let x = foo.x;            // x = 100
    let x_copy = foo_copy.x;  // x = 100

    // foo와 foo_copy 모두 함수가 반환될 때 암시적으로 폐기됩니다
}
```

## 스토리지

구조체는 스토리지 스키마를 정의하는 데 사용할 수 있지만, 세부 사항은 Move 배포마다 다릅니다. 자세한 내용은 [`key` ability](./abilities#key)와 [Sui objects](./abilities/object) 문서를 참조하세요.