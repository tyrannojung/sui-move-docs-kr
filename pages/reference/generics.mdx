---
title: 'Generics | Reference'
description: ''
---

# 제네릭

제네릭은 다양한 입력 데이터 타입에 대해 함수와 구조체를 정의하는 데 사용할 수 있습니다. 이 언어 기능은 때때로 매개변수적 다형성(parametric polymorphism)이라고도 합니다. Move에서는 제네릭이라는 용어를 _타입 매개변수_ 및 _타입 인자_와 같은 의미로 사용합니다.

제네릭은 [vector](./primitive-types/vector)와 같은 라이브러리 코드에서 일반적으로 사용되어, (지정된 제약 조건을 만족하는) 모든 가능한 타입에 대해 작동하는 코드를 선언합니다. 이러한 종류의 매개변수화를 통해 여러 타입과 상황에서 동일한 구현을 재사용할 수 있습니다.

## 타입 매개변수 선언하기

함수와 구조체 모두 시그니처에서 꺾쇠 괄호 `<...>`로 둘러싸인 타입 매개변수 목록을 받을 수 있습니다.

### 제네릭 함수

함수의 타입 매개변수는 함수 이름 뒤와 (값) 매개변수 목록 앞에 위치합니다. 다음 코드는 어떤 타입의 값을 받아서 변경하지 않고 그대로 반환하는 제네릭 항등 함수를 정의합니다.

```move
fun id<T>(x: T): T {
    // 이 타입 주석은 불필요하지만 유효합니다
    (x: T)
}
```

일단 정의되면, 타입 매개변수 `T`는 매개변수 타입, 반환 타입, 그리고 함수 본문 내부에서 사용할 수 있습니다.

### 제네릭 구조체

구조체의 타입 매개변수는 구조체 이름 뒤에 위치하며, 필드의 타입을 명명하는 데 사용할 수 있습니다.

```move
public struct Foo<T> has copy, drop { x: T }

public struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
```

[타입 매개변수는 사용되지 않아도 됩니다](#unused-type-parameters)

## 타입 인자

### 제네릭 함수 호출하기

제네릭 함수를 호출할 때, 꺾쇠 괄호로 둘러싸인 목록에서 함수의 타입 매개변수에 대한 타입 인자를 지정할 수 있습니다.

```move
fun foo() {
    let x = id<bool>(true);
}
```

타입 인자를 지정하지 않으면, Move의 [타입 추론](#type-inference)이 대신 제공합니다.

### 제네릭 구조체 사용하기

마찬가지로, 제네릭 타입의 값을 생성하거나 해체할 때 구조체의 타입 매개변수에 대한 타입 인자 목록을 첨부할 수 있습니다.

```move
fun foo() {
    // 생성 시 타입 인자
    let foo = Foo<bool> { x: true };
    let bar = Bar<u64, u8> { x: 0, y: vector<u8>[] };

    // 해체 시 타입 인자
    let Foo<bool> { x } = foo;
    let Bar<u64, u8> { x, y } = bar;
}
```

어떤 경우든 타입 인자를 지정하지 않으면, Move의 [타입 추론](#type-inference)이 대신 제공합니다.

### 타입 인자 불일치

타입 인자를 지정했는데 실제로 제공된 값과 충돌하면 오류가 발생합니다:

```move
fun foo() {
    let x = id<u64>(true); // 오류! true는 u64가 아닙니다
}
```

그리고 유사하게:

```move
fun foo() {
    let foo = Foo<bool> { x: 0 }; // 오류! 0은 bool이 아닙니다
    let Foo<address> { x } = foo; // 오류! bool은 address와 호환되지 않습니다
}
```

## 타입 추론

대부분의 경우, Move 컴파일러는 타입 인자를 추론할 수 있으므로 명시적으로 작성할 필요가 없습니다. 타입 인자를 생략하면 위의 예제는 다음과 같이 보입니다:

```move
fun foo() {
    let x = id(true);
    //        ^ <bool>이 추론됩니다

    let foo = Foo { x: true };
    //           ^ <bool>이 추론됩니다

    let Foo { x } = foo;
    //     ^ <bool>이 추론됩니다
}
```

참고: 컴파일러가 타입을 추론할 수 없을 때는 수동으로 주석을 달아야 합니다. 일반적인 시나리오는 반환 위치에만 나타나는 타입 매개변수가 있는 함수를 호출하는 것입니다.

```move
module a::m;

fun foo() {
    let v = vector[]; // 오류!
    //            ^ 컴파일러는 요소 타입을 알아낼 수 없습니다. 사용되지 않기 때문입니다

    let v = vector<u64>[];
    //            ^~~~~ 이 경우 수동으로 주석을 달아야 합니다.
}
```

이러한 경우는 `vector[]`가 전혀 사용되지 않아서 다소 인위적이며, 따라서 Move의 타입 추론이 타입을 추론할 수 없습니다.

하지만 해당 값이 함수에서 나중에 사용되면 컴파일러가 타입을 추론할 수 있습니다:

```move
module a::m;

fun foo() {
    let v = vector[];
    //            ^ <u64>가 추론됩니다
    vector::push_back(&mut v, 42);
    //               ^ <u64>가 추론됩니다
}
```

### `_` 타입

일부 경우에는 일부 타입 인자를 명시적으로 주석 달고 싶지만 나머지는 컴파일러가 추론하도록 하고 싶을 수 있습니다. `_` 타입은 컴파일러가 타입을 추론하도록 하는 자리 표시자 역할을 합니다.

```move
let bar = Bar<u64, _> { x: 0, y: vector[b"hello"] };
//                 ^ vector<u8>이 추론됩니다
```

자리 표시자 `_`는 표현식과 매크로 함수 정의에만 나타날 수 있으며, 시그니처에는 나타날 수 없습니다.
즉, 함수 매개변수, 함수 반환 타입, 상수 정의 타입, 데이터 타입 필드의 정의 부분으로 `_`를 사용할 수 없습니다.

## 정수

Move에서 정수 타입 `u8`, `u16`, `u32`, `u64`, `u128`, `u256`은 모두 별개의 타입입니다.
하지만 이러한 각 타입은 동일한 숫자 값 구문으로 생성할 수 있습니다. 다시 말해, 타입 접미사가 제공되지 않으면 컴파일러는 값의 사용에 따라 정수 타입을 추론합니다.

```move
let x8: u8 = 0;
let x16: u16 = 0;
let x32: u32 = 0;
let x64: u64 = 0;
let x128: u128 = 0;
let x256: u256 = 0;
```

값이 특정 정수 타입을 요구하는 컨텍스트에서 사용되지 않으면 기본값으로 `u64`가 사용됩니다.

```move
let x = 0;
//      ^ 기본적으로 u64가 사용됩니다
```

하지만 값이 추론된 타입에 비해 너무 크면 오류가 발생합니다

```move
let i: u8 = 256; // 오류!
//          ^^^ u8에 너무 큽니다
let x = 340282366920938463463374607431768211454;
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u64에 너무 큽니다
```

숫자가 너무 큰 경우 명시적으로 주석을 달아야 할 수 있습니다

```move
let x = 340282366920938463463374607431768211454u128;
//                                             ^^^^ 유효합니다!
```

## 사용되지 않는 타입 매개변수

구조체 정의에서 사용되지 않는 타입 매개변수는 구조체에 정의된 어떤 필드에도 나타나지 않는 매개변수이지만 컴파일 시간에 정적으로 검사됩니다. Move는 사용되지 않는 타입 매개변수를 허용하므로 다음 구조체 정의가 유효합니다:

```move
public struct Foo<T> {
    foo: u64
}
```

이는 특정 개념을 모델링할 때 편리할 수 있습니다. 다음은 예제입니다:

```move
module a::m;

// 통화 지정자
public struct A {}
public struct B {}

// 통화 지정자 타입을 사용하여 인스턴스화할 수 있는 
// 제네릭 코인 타입.
//   예: Coin<A>, Coin<B> 등.
public struct Coin<Currency> has store {
    value: u64
}

// 모든 통화에 대해 제네릭하게 코드 작성
public fun mint_generic<Currency>(value: u64): Coin<Currency> {
    Coin { value }
}

// 특정 통화에 대해 구체적으로 코드 작성
public fun mint_a(value: u64): Coin<A> {
    mint_generic(value)
}
public fun mint_b(value: u64): Coin<B> {
    mint_generic(value)
}
```

이 예제에서 `Coin<Currency>`는 `Currency` 타입 매개변수에 대해 제네릭이며, 이는 코인의 통화를 지정하고 모든 통화에 대해 제네릭하게 또는 특정 통화에 대해 구체적으로 코드를 작성할 수 있게 합니다. 이러한 일반성은 `Currency` 타입 매개변수가 `Coin`에 정의된 어떤 필드에도 나타나지 않더라도 적용됩니다.

### 팬텀 타입 매개변수

위의 예제에서 `struct Coin`이 `store` ability를 요구하지만, `Coin<A>`나 `Coin<B>` 둘 다 `store` ability를 가지지 않습니다. 이는 [조건부 Ability와 제네릭 타입](./abilities#conditional-abilities-and-generic-types)의 규칙과 `A`와 `B`가 `struct Coin`의 본문에서 사용되지 않음에도 불구하고 `store` ability를 가지지 않는다는 사실 때문입니다. 이는 몇 가지 불쾌한 결과를 초래할 수 있습니다. 예를 들어, `Coin<A>`를 스토리지의 지갑에 넣을 수 없습니다.

한 가지 가능한 해결책은 `A`와 `B`에 가짜 ability 주석을 추가하는 것입니다(즉, `public struct Currency1 has store {}`). 하지만 이는 불필요한 ability 선언으로 타입을 약화시키기 때문에 버그나 보안 취약점으로 이어질 수 있습니다. 예를 들어, 스토리지의 값이 타입 `A`의 필드를 가질 것으로 기대하지 않지만, 가짜 `store` ability로 인해 가능해집니다. 또한 가짜 주석은 전염성이 있어, 사용되지 않는 타입 매개변수에 제네릭한 많은 함수가 필요한 제약 조건을 포함해야 합니다.

팬텀 타입 매개변수는 이 문제를 해결합니다. 사용되지 않는 타입 매개변수는 _팬텀_ 타입 매개변수로 표시될 수 있으며, 이는 구조체의 ability 파생에 참여하지 않습니다. 이런 방식으로 팬텀 타입 매개변수에 대한 인자는 제네릭 타입의 ability를 파생할 때 고려되지 않으므로 가짜 ability 주석의 필요성을 피할 수 있습니다. 이 완화된 규칙이 건전하려면, Move의 타입 시스템은 `phantom`으로 선언된 매개변수가 구조체 정의에서 전혀 사용되지 않거나 `phantom`으로 선언된 타입 매개변수의 인자로만 사용되도록 보장합니다.

#### 선언

구조체 정의에서 타입 매개변수는 선언 앞에 `phantom` 키워드를 추가하여 팬텀으로 선언할 수 있습니다.

```move
public struct Coin<phantom Currency> has store {
    value: u64
}
```

타입 매개변수가 팬텀으로 선언되면 팬텀 타입 매개변수라고 합니다. 구조체를 정의할 때 Move의 타입 검사기는 모든 팬텀 타입 매개변수가 구조체 정의 내부에서 사용되지 않거나 팬텀 타입 매개변수의 인자로만 사용되도록 보장합니다.

```move
public struct S1<phantom T1, T2> { f: u64 }
//               ^^^^^^^ 유효함, T1은 구조체 정의 내부에 나타나지 않습니다

public struct S2<phantom T1, T2> { f: S1<T1, T2> }
//               ^^^^^^^ 유효함, T1은 팬텀 위치에 나타납니다
```

다음 코드는 규칙 위반의 예를 보여줍니다:

```move
public struct S1<phantom T> { f: T }
//               ^^^^^^^ 오류!  ^ 팬텀 위치가 아닙니다

public struct S2<T> { f: T }
public struct S3<phantom T> { f: S2<T> }
//               ^^^^^^^ 오류!     ^ 팬텀 위치가 아닙니다
```

더 공식적으로, 타입이 팬텀 타입 매개변수의 인자로 사용되면 타입이 _팬텀 위치_에 나타난다고 말합니다. 이 정의를 바탕으로 팬텀 매개변수의 올바른 사용에 대한 규칙은 다음과 같이 지정할 수 있습니다: **팬텀 타입 매개변수는 팬텀 위치에만 나타날 수 있습니다**.

`phantom`을 지정하는 것은 필수가 아니지만, 타입 매개변수가 `phantom`일 수 있지만 그렇게 표시되지 않은 경우 컴파일러가 경고합니다.

#### 인스턴스화

구조체를 인스턴스화할 때, 팬텀 매개변수에 대한 인자는 구조체 ability를 파생할 때 제외됩니다. 예를 들어, 다음 코드를 고려하세요:

```move
public struct S<T1, phantom T2> has copy { f: T1 }
public struct NoCopy {}
public struct HasCopy has copy {}
```

이제 `S<HasCopy, NoCopy>` 타입을 고려해보세요. `S`가 `copy`로 정의되고 모든 비팬텀 인자가 `copy`를 가지므로 `S<HasCopy, NoCopy>`도 `copy`를 가집니다.

#### Ability 제약이 있는 팬텀 타입 매개변수

Ability 제약과 팬텀 타입 매개변수는 직교 기능이므로 팬텀 매개변수를 ability 제약과 함께 선언할 수 있습니다.

```move
public struct S<phantom T: copy> {}
```

ability 제약이 있는 팬텀 타입 매개변수를 인스턴스화할 때, 매개변수가 팬텀이더라도 타입 인자는 해당 제약을 만족해야 합니다. 일반적인 제한이 적용되며 `T`는 `copy`를 가진 인자로만 인스턴스화할 수 있습니다.

## 제약 조건

위의 예제에서는 타입 매개변수를 사용하여 나중에 호출자가 연결할 수 있는 "알 수 없는" 타입을 정의하는 방법을 보여주었습니다. 그러나 이는 타입 시스템이 타입에 대한 정보가 거의 없고 매우 보수적인 방식으로 검사를 수행해야 함을 의미합니다. 어떤 의미에서 타입 시스템은 제약이 없는 제네릭에 대한 최악의 시나리오를 가정해야 합니다--[ability](./abilities)가 없는 타입.

제약 조건은 이러한 알 수 없는 타입이 가진 속성을 지정하는 방법을 제공하므로 타입 시스템이 그렇지 않으면 안전하지 않은 작업을 허용할 수 있습니다.

### 제약 조건 선언하기

다음 구문을 사용하여 타입 매개변수에 제약 조건을 부과할 수 있습니다.

```move
// T는 타입 매개변수의 이름입니다
T: <ability> (+ <ability>)*
```

`<ability>`는 네 가지 [ability](./abilities) 중 하나일 수 있으며, 타입 매개변수는 한 번에 여러 ability로 제약될 수 있습니다. 따라서 다음은 모두 유효한 타입 매개변수 선언입니다:

```move
T: copy
T: copy + drop
T: copy + drop + store + key
```

### 제약 조건 확인하기

제약 조건은 인스턴스화 사이트에서 확인됩니다

```move
public struct Foo<T: copy> { x: T }

public struct Bar { x: Foo<u8> }
//                         ^^ 유효함, u8은 `copy`를 가집니다

public struct Baz<T> { x: Foo<T> }
//                            ^ 오류! T는 'copy'를 가지지 않습니다
```

그리고 함수에 대해서도 유사합니다

```move
fun unsafe_consume<T>(x: T) {
    // 오류! x는 'drop'을 가지지 않습니다
}

fun consume<T: drop>(x: T) {
    // 유효함, x는 자동으로 삭제됩니다
}

public struct NoAbilities {}

fun foo() {
    let r = NoAbilities {};
    consume<NoAbilities>(NoAbilities);
    //      ^^^^^^^^^^^ 오류! NoAbilities는 'drop'을 가지지 않습니다
}
```

그리고 `copy`와 유사한 예제들:

```move
fun unsafe_double<T>(x: T) {
    (copy x, x)
    // 오류! T는 'copy'를 가지지 않습니다
}

fun double<T: copy>(x: T) {
    (copy x, x) // 유효함, T는 'copy'를 가집니다
}

public struct NoAbilities {}

fun foo(): (NoAbilities, NoAbilities) {
    let r = NoAbilities {};
    double<NoAbilities>(r)
    //     ^ 오류! NoAbilities는 'copy'를 가지지 않습니다
}
```

자세한 정보는 abilities 섹션의 [조건부 ability와 제네릭 타입](./abilities#conditional-abilities-and-generic-types)을 참조하세요.

## 재귀에 대한 제한 사항

### 재귀적 구조체

제네릭 구조체는 다른 타입 인자를 사용하더라도 직접적이든 간접적이든 같은 타입의 필드를 포함할 수 없습니다. 다음 구조체 정의는 모두 유효하지 않습니다:

```move
public struct Foo<T> {
    x: Foo<u64> // 오류! 'Foo'가 'Foo'를 포함합니다
}

public struct Bar<T> {
    x: Bar<T> // 오류! 'Bar'가 'Bar'를 포함합니다
}

// 오류! 'A'와 'B'가 순환을 형성하며, 이 또한 허용되지 않습니다.
public struct A<T> {
    x: B<T, u64>
}

public struct B<T1, T2> {
    x: A<T1>
    y: A<T2>
}
```

### 고급 주제: 타입 수준 재귀

Move는 제네릭 함수가 재귀적으로 호출되는 것을 허용합니다. 그러나 제네릭 구조체와 함께 사용될 때, 이는 특정 경우에 무한한 수의 타입을 생성할 수 있으며, 이를 허용하면 컴파일러, VM 및 기타 언어 구성 요소에 불필요한 복잡성이 추가됩니다. 따라서 이러한 재귀는 금지됩니다.

이 제한은 미래에 완화될 수 있지만, 지금은 다음 예제가 무엇이 허용되고 무엇이 허용되지 않는지에 대한 아이디어를 제공합니다.

```move
module a::m;

public struct A<T> {}

// 유한한 타입 -- 허용됨.
// foo<T> -> foo<T> -> foo<T> -> ...는 유효합니다
fun foo<T>() {
    foo<T>();
}

// 유한한 타입 -- 허용됨.
// foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ...는 유효합니다
fun foo<T>() {
    foo<A<u64>>();
}
```

허용되지 않음:

```move
module a::m;

public struct A<T> {}

// 무한한 타입 -- 허용되지 않음.
// 오류!
// foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...
fun foo<T>() {
    foo<Foo<T>>();
}
```

그리고 유사하게, 허용되지 않음:

```move
module a::n;

public struct A<T> {}

// 무한한 타입 -- 허용되지 않음.
// 오류!
// foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>
//   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>
//   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>
//   -> ...
fun foo<T1, T2>() {
    bar<T2, T1>();
}

fun bar<T1, T2> {
    foo<T1, A<T2>>();
}
```

타입 수준 재귀에 대한 검사는 호출 사이트에 대한 보수적인 분석을 기반으로 하며 제어 흐름이나 런타임 값을 고려하지 않습니다.

```move
module a::m;

public struct A<T> {}

// 무한한 타입 -- 허용되지 않음.
// 오류!
fun foo<T>(n: u64) {
    if (n > 0) foo<A<T>>(n - 1);
}
```

위 예제의 함수는 기술적으로 주어진 입력에 대해 종료되므로 유한한 타입만 생성하지만, Move의 타입 시스템에서는 여전히 유효하지 않은 것으로 간주됩니다.