---
title: 'Packages | Reference'
description: ''
---

# 패키지

패키지는 Move 프로그래머들이 코드를 더 쉽게 재사용하고 프로젝트 간에 공유할 수 있도록 해줍니다. Move 패키지 시스템을 통해 프로그래머들은 다음을 쉽게 할 수 있습니다:

- Move 코드를 포함하는 패키지 정의
- [명명된 주소](./primitive-types/address)로 패키지 매개변수화
- 다른 Move 코드에서 패키지를 가져와 사용하고 명명된 주소 인스턴스화
- 패키지에서 빌드하고 관련 컴파일 아티팩트 생성
- 컴파일된 Move 아티팩트 주변의 공통 인터페이스로 작업

## 패키지 레이아웃과 매니페스트 구문

Move 패키지 소스 디렉토리는 `Move.toml` 패키지 매니페스트 파일, 생성된 `Move.lock` 파일, 그리고 하위 디렉토리 세트를 포함합니다:

```plaintext
a_move_package
├── Move.toml      (필수)
├── Move.lock      (생성됨)
├── sources        (필수)
├── doc_templates  (선택)
├── examples       (선택, test & dev 모드)
└── tests          (선택, test 모드)
```

"필수"로 표시된 디렉토리와 파일은 디렉토리가 Move 패키지로 간주되고 빌드되기 위해 반드시 존재해야 합니다. 선택적 디렉토리는 존재할 수 있으며, 존재하는 경우 패키지를 빌드하는 데 사용되는 모드에 따라 컴파일 과정에 포함됩니다. 예를 들어, "dev" 또는 "test" 모드로 빌드할 때는 `tests`와 `examples` 디렉토리도 포함됩니다.

각각을 차례로 살펴보면:

1. [`Move.toml`](#movetoml) 파일은 패키지 매니페스트이며 디렉토리가 Move 패키지로 간주되기 위해 필요합니다. 이 파일은 이름, 의존성 등과 같은 패키지에 대한 메타데이터를 포함합니다.
1. [`Move.lock`](#movelock) 파일은 Move CLI에 의해 생성되며 패키지와 그 의존성의 고정된 빌드 버전을 포함합니다. 이는 서로 다른 빌드에서 일관된 버전이 사용되도록 하고 의존성의 변경이 이 파일의 변경으로 명확하게 나타나도록 하는 데 사용됩니다.
1. `sources` 디렉토리는 필수이며 패키지를 구성하는 Move 모듈을 포함합니다. 이 디렉토리의 모듈은 항상 컴파일 과정에 포함됩니다.
1. `doc_templates` 디렉토리는 패키지에 대한 문서를 생성할 때 사용될 문서 템플릿을 포함할 수 있습니다.
1. `examples` 디렉토리는 개발 및/또는 튜토리얼에만 사용되는 추가 코드를 보관할 수 있으며, `test` 또는 `dev` 모드 외에서 컴파일할 때는 포함되지 않습니다.
1. `tests` 디렉토리는 `test` 모드로 컴파일하거나 [Move 단위 테스트](./unit-testing)를 실행할 때만 포함되는 Move 모듈을 포함할 수 있습니다.

### Move.toml

Move 패키지 매니페스트는 `Move.toml` 파일 내에 정의되며 다음과 같은 구문을 가집니다.
선택적 필드는 `*`로 표시되고, `+`는 하나 이상의 요소를 나타냅니다:

```toml
[package]
name = <string>
edition* = <string>      # 예: Move 2024 에디션을 사용하려면 "2024.alpha",
                         # 현재 알파 버전. 지정하지 않으면 최신 안정 버전이 기본값
license* = <string>              # 예: "MIT", "GPL", "Apache 2.0"
authors* = [<string>,+]  # 예: ["Joe Smith (joesmith@noemail.com)", "John Snow (johnsnow@noemail.com)"]

# 외부 도구에 의해 이 섹션에 추가 필드가 추가될 수 있습니다. 예: Sui에서는 다음 섹션이 추가됩니다:
published-at* = "<hex-address>" # 패키지가 게시된 주소. 첫 번째 게시 후에 설정되어야 합니다.

[dependencies] # (선택 섹션) 의존성 경로
# 다음 형식으로 의존성을 선언하는 하나 이상의 줄

# ##### 로컬 의존성 #####
# 로컬 의존성의 경우 `local = path`를 사용합니다. 경로는 패키지 루트에 상대적입니다
# Local = { local = "../path/to" }
# 버전 충돌을 해결하고 의존성에 대한 특정 버전을 강제하려면
# `override = true`를 사용할 수 있습니다
# Override = { local = "../conflicting/version", override = true }
# 의존성에서 주소 값을 인스턴스화하려면 `addr_subst`를 사용합니다
<string> = {
    local = <string>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}

# ##### Git 의존성 #####
# 원격 가져오기의 경우 `{ git = "...", subdir = "...", rev = "..." }`를 사용합니다.
# 리비전을 반드시 제공해야 하며, 브랜치, 태그 또는 커밋 해시가 될 수 있습니다.
# `subdir`이 지정되지 않으면 저장소의 루트가 사용됩니다.
# MyRemotePackage = { git = "https://some.remote/host.git", subdir = "remote/path", rev = "main" }
<string> = {
    git = <URL ending in .git>,
    subdir=<path to dir containing Move.toml inside git repo>,
    rev=<git commit hash>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}

[addresses]  # (선택 섹션) 이 패키지의 명명된 주소 선언
# 다음 형식으로 명명된 주소를 선언하는 하나 이상의 줄
# 패키지 이름과 일치하는 주소는 `"0x0"`으로 설정해야 하며, 그렇지 않으면 게시할 수 없습니다.
<addr_name> = "_" | "<hex_address>" # 예: std = "_" 또는 my_addr = "0xC0FFEECAFE"

# 명명된 주소는 Move에서 `@name`으로 접근할 수 있습니다. 또한 내보내집니다:
# 예를 들어, `std = "0x1"`은 표준 라이브러리에 의해 내보내집니다.
# alice = "0xA11CE"

[dev-dependencies] # (선택 섹션) [dependencies] 섹션과 동일하지만 "dev"와 "test" 모드에서만 포함됨
# dev-dependencies 섹션은 `--test`와 `--dev` 모드에 대한 의존성을 재정의할 수 있습니다.
# 여기서 테스트 전용 의존성을 도입할 수 있습니다.
# Local = { local = "../path/to/dev-build" }
<string> = {
    local = <string>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}
<string> = {
    git = <URL ending in .git>,
    subdir=<path to dir containing Move.toml inside git repo>,
    rev=<git commit hash>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}

[dev-addresses] # (선택 섹션) [addresses] 섹션과 동일하지만 "dev"와 "test" 모드에서만 포함됨
# dev-addresses 섹션은 `--test`와 `--dev` 모드에 대한 명명된 주소를 재정의할 수 있습니다.
<addr_name> = "<hex_address>" # 예: alice = "0xB0B"
```

최소한의 패키지 매니페스트 예시:

```toml
[package]
name = "AName"
```

Move 표준 라이브러리도 포함하고 `LocalDep` 패키지의 명명된 주소 `std`를 주소 값 `0x1`로 인스턴스화하는 보다 표준적인 패키지 매니페스트 예시:

```toml
[package]
name = "AName"
license = "Apache 2.0"

[addresses]
address_to_be_filled_in = "_"
specified_address = "0xB0B"

[dependencies]
# 로컬 의존성
LocalDep = { local = "projects/move-awesomeness", addr_subst = { "std" = "0x1" } }
# Git 의존성
MoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }

[dev-addresses] # 이 모듈을 개발할 때 사용
address_to_be_filled_in = "0x101010101"
```

패키지 매니페스트의 대부분의 섹션은 자명하지만, 명명된 주소는 이해하기 어려울 수 있으므로 
[컴파일 중 명명된 주소](#named-addresses-during-compilation)에서 더 자세히 살펴봅니다.

## 컴파일 중 명명된 주소

Move에는 [명명된 주소](./primitive-types/address)가 있고 명명된 주소는 Move에서 선언할 수 없다는 점을 기억하세요. 대신 패키지 수준에서 선언됩니다: Move 패키지의 매니페스트 파일(`Move.toml`)에서 패키지의 명명된 주소를 선언하고, 다른 명명된 주소를 인스턴스화하며, Move 패키지 시스템 내의 다른 패키지에서 명명된 주소의 이름을 변경합니다.

이러한 각 작업과 패키지의 매니페스트에서 수행되는 방법을 하나씩 살펴보겠습니다:

### 명명된 주소 선언하기

`example_pkg/sources/A.move`에 다음과 같은 Move 모듈이 있다고 가정해 보겠습니다:

```move
module named_addr::a {
    public fun x(): address { @named_addr }
}
```

`example_pkg/Move.toml`에서 명명된 주소 `named_addr`을 두 가지 다른 방법으로 선언할 수 있습니다.
첫 번째:

```toml
[package]
name = "example_pkg"
...
[addresses]
named_addr = "_"
```

이는 `named_addr`을 패키지 `example_pkg`의 명명된 주소로 선언하고 _이 주소가 유효한 주소 값이 될 수 있음_을 나타냅니다. 특히, 가져오는 패키지는 명명된 주소 `named_addr`의 값을 원하는 주소로 선택할 수 있습니다. 직관적으로 이것은 명명된 주소 `named_addr`로 패키지 `example_pkg`를 매개변수화하는 것으로 생각할 수 있으며, 패키지는 나중에 가져오는 패키지에 의해 인스턴스화될 수 있습니다.

`named_addr`은 다음과 같이 선언될 수도 있습니다:

```toml
[package]
name = "example_pkg"
...
[addresses]
named_addr = "0xCAFE"
```

이는 명명된 주소 `named_addr`이 정확히 `0xCAFE`이며 변경할 수 없음을 나타냅니다. 이는 다른 가져오는 패키지가 할당된 정확한 값에 대해 걱정할 필요 없이 이 명명된 주소를 사용할 수 있도록 하는 데 유용합니다.

이 두 가지 다른 선언 방법으로, 명명된 주소에 대한 정보가 패키지 그래프에서 흐를 수 있는 두 가지 방법이 있습니다:

- 전자("할당되지 않은 명명된 주소")는 명명된 주소 값이 가져오기 사이트에서 선언 사이트로 흐르도록 허용합니다.
- 후자("할당된 명명된 주소")는 명명된 주소 값이 선언 사이트에서 패키지 그래프를 따라 위쪽으로 사용 사이트로 흐르도록 허용합니다.

패키지 그래프 전체에서 명명된 주소 정보를 흐르게 하는 이 두 가지 방법으로 인해 범위 지정과 이름 변경에 관한 규칙을 이해하는 것이 중요해집니다.

## 명명된 주소의 범위와 이름 변경

패키지 `P`의 명명된 주소 `N`은 다음과 같은 경우 범위 내에 있습니다:

1. `P`가 명명된 주소 `N`을 선언하거나
2. `P`의 전이적 의존성 중 하나의 패키지가 명명된 주소 `N`을 선언하고 `P`와 `N`의 선언 패키지 사이의 패키지 그래프에 `N`의 이름 변경이 없는 의존성 경로가 있는 경우.

또한, 패키지의 모든 명명된 주소는 내보내집니다. 이와 위의 범위 지정 규칙 때문에 각 패키지는 패키지를 가져올 때 범위에 들어올 명명된 주소 세트와 함께 제공되는 것으로 볼 수 있습니다. 예를 들어, `example_pkg`를 가져오면 해당 가져오기는 `named_addr` 명명된 주소도 범위에 가져옵니다. 이 때문에 `P`가 둘 다 명명된 주소 `N`을 선언하는 두 패키지 `P1`과 `P2`를 가져오면 `P`에서 문제가 발생합니다: `P`에서 `N`을 참조할 때 어떤 "`N`"을 의미하는가? `P1`의 것인가 `P2`의 것인가? 명명된 주소가 어떤 패키지에서 오는지에 대한 이러한 모호성을 방지하기 위해, 패키지의 모든 의존성에 의해 도입된 범위 세트가 서로 겹치지 않도록 강제하고, 범위에 가져오는 패키지를 가져올 때 _명명된 주소의 이름을 변경_하는 방법을 제공합니다.

위의 `P`, `P1`, `P2` 예시에서 가져올 때 명명된 주소의 이름을 변경하는 방법은 다음과 같습니다:

```toml
[package]
name = "P"
...
[dependencies]
P1 = { local = "some_path_to_P1", addr_subst = { "P1N" = "N" } }
P2 = { local = "some_path_to_P2"  }
```

이 이름 변경으로 `N`은 `P2`의 `N`을 참조하고 `P1N`은 `P1`에서 오는 `N`을 참조합니다:

```move
module N::A {
    public fun x(): address { @P1N }
}
```

_이름 변경은 로컬이 아님_을 주목하는 것이 중요합니다: 패키지 `P`에서 명명된 주소 `N`이 `N2`로 이름이 변경되면 `P`를 가져오는 모든 패키지는 `N`이 `P` 외부에서 다시 도입되지 않는 한 `N`이 아닌 `N2`만 볼 수 있습니다. 이것이 이 섹션 시작 부분의 범위 지정 규칙의 규칙 (2)가 "`P`와 `N`의 선언 패키지 사이의 패키지 그래프에 `N`의 이름 변경이 없는 의존성 경로"를 지정하는 이유입니다.

### 명명된 주소 인스턴스화하기

명명된 주소는 항상 동일한 값으로 인스턴스화되는 한 패키지 그래프 전체에서 여러 번 인스턴스화될 수 있습니다. 동일한 명명된 주소(이름 변경과 관계없이)가 패키지 그래프 전체에서 다른 값으로 인스턴스화되면 오류입니다.

모든 명명된 주소가 값으로 해결되는 경우에만 Move 패키지를 컴파일할 수 있습니다. 이는 패키지가 인스턴스화되지 않은 명명된 주소를 노출하려는 경우 문제를 제시합니다. 이것이 `[dev-addresses]` 섹션이 부분적으로 해결하는 것입니다. 이 섹션은 명명된 주소에 대한 값을 설정할 수 있지만 명명된 주소를 도입할 수는 없습니다. 또한 루트 패키지의 `[dev-addresses]`만 `dev` 모드에 포함됩니다. 예를 들어 다음 매니페스트가 있는 루트 패키지는 `named_addr`이 인스턴스화되지 않으므로 `dev` 모드 외부에서는 컴파일되지 않습니다:

```toml
[package]
name = "example_pkg"
...
[addresses]
named_addr = "_"

[dev-addresses]
named_addr = "0xC0FFEE"
```

## 사용법과 아티팩트

Move 패키지 시스템은 CLI의 일부로 명령줄 옵션과 함께 제공됩니다:
`sui move <command> <command_flags>`. 특정 경로가 제공되지 않는 한, 모든 패키지 명령은 현재 둘러싸는 Move 패키지에서 실행됩니다. Move CLI의 전체 명령 및 플래그 목록은 `sui move --help`를 실행하여 찾을 수 있습니다.

### 아티팩트

패키지는 CLI 명령을 사용하여 컴파일할 수 있습니다. 이렇게 하면 빌드 관련 아티팩트(바이트코드 바이너리, 소스 맵, 문서 포함)를 포함하는 `build` 디렉토리가 생성됩니다. `build` 디렉토리의 일반적인 레이아웃은 다음과 같습니다:

```plaintext
a_move_package
├── BuildInfo.yaml
├── bytecode_modules
│   ├── dependencies
│   │   ├── <dep_pkg_name>
│   │   │   └── *.mv
│   │   ...
│   │   └──  <dep_pkg_name>
│   │       └── *.mv
│   ...
│   └── *.mv
├── docs
│   ├── dependencies
│   │   ├── <dep_pkg_name>
│   │   │   └── *.md
│   │   ...
│   │   └──  <dep_pkg_name>
│   │       └── *.md
│   ...
│   └── *.md
├── source_maps
│   ├── dependencies
│   │   ├── <dep_pkg_name>
│   │   │   └── *.mvsm
│   │   ...
│   │   └──  <dep_pkg_name>
│   │       └── *.mvsm
│   ...
│   └── *.mvsm
└── sources
    ...
    └── *.move
    ├── dependencies
    │   ├── <dep_pkg_name>
    │   │   └── *.move
    │   ...
    │   └──  <dep_pkg_name>
    │       └── *.move
    ...
    └── *.move
```

## Move.lock

`Move.lock` 파일은 패키지가 빌드될 때 Move 패키지의 루트에 생성됩니다. `Move.lock` 파일은 패키지와 빌드 구성에 대한 정보를 포함하며, Move 컴파일러와 체인별 명령줄 인터페이스 및 서드파티 패키지 관리자와 같은 다른 도구 간의 통신 계층 역할을 합니다.

`Move.toml` 파일과 마찬가지로 `Move.lock` 파일은 텍스트 기반 TOML 파일입니다. 그러나 패키지 매니페스트와 달리 `Move.lock` 파일은 직접 편집하도록 의도되지 않았습니다. Move 컴파일러와 같은 툴체인의 프로세스가 파일에 접근하고 편집하여 관련 정보를 읽고 추가합니다. 또한 파일이 패키지의 `Move.toml` 매니페스트와 같은 수준에 있어야 하므로 루트에서 파일을 이동해서는 안 됩니다.

패키지에 소스 제어를 사용하는 경우, 원하는 빌드 또는 게시된 패키지에 해당하는 `Move.lock` 파일을 체크인하는 것이 권장되는 관행입니다. 이렇게 하면 패키지의 모든 빌드가 원본의 정확한 복제본이 되고 빌드에 대한 변경 사항이 `Move.lock` 파일의 변경 사항으로 명확하게 나타나도록 합니다.

`Move.lock` 파일은 현재 다음 필드를 포함하는 TOML 파일입니다.

**참고**: 미래에 또는 서드파티 패키지 관리자에 의해 lock 파일에 다른 필드가 추가될 수도 있습니다.

### `[move]` 섹션

이 섹션은 lockfile에 필요한 핵심 정보를 포함합니다:

- lockfile의 버전 (이전 버전과의 호환성 확인 및 향후 lockfile 변경 사항 버전 관리에 필요).
- 이 lock 파일을 생성하는 데 사용된 `Move.toml` 파일의 해시.
- 모든 의존성의 `Move.lock` 파일의 해시. 의존성이 없으면 빈 문자열이 됩니다.
- 의존성 목록.

```toml
[move]
version = <string> # Lock 파일 버전, 이전 버전과의 호환성 확인에 사용됨.
manifest_digest = <hash> # 이 lock 파일을 생성하는 데 사용된 Move.toml 파일의 Sha3-256 해시.
deps_digest = <hash> # 모든 의존성의 Move.lock 파일의 Sha3-256 해시. 의존성이 없으면 빈 문자열이 됩니다.
dependencies = { (name = <string>)* } # 의존성 목록. 의존성이 없으면 존재하지 않습니다.
```

### `[move.package]` 섹션

Move 컴파일러가 패키지의 각 의존성을 해결한 후 의존성의 위치를 `Move.lock` 파일에 씁니다. 의존성을 해결하지 못하면 컴파일러는 `Move.lock` 파일을 작성하지 않고 빌드가 실패합니다. 모든 의존성이 해결되면 `Move.lock` 파일에는 패키지의 모든 전이적 의존성의 위치(로컬 및 원격)가 포함됩니다. 이들은 다음 형식으로 `Move.lock` 파일에 저장됩니다:

```toml
# ...

[[move.package]]
name = "A"
source = { git = "https://github.com/b/c.git", subdir = "e/f", rev = "a1b2c3" }

[[move.package]]
name = "B"
source = { local = "../local-dep" }
```

### `[move.toolchain-version]` 섹션

위에서 언급했듯이 외부 도구에 의해 lock 파일에 추가 필드가 추가될 수 있습니다. 예를 들어, Sui 패키지 관리자는 온체인 소스 검증에 사용할 수 있는 툴체인 버전 정보를 lock 파일에 추가합니다:

```toml
# ...

[move.toolchain-version]
compiler-version = <string> # 패키지를 빌드하는 데 사용된 Move 컴파일러의 버전, 예: "1.21.0"
edition = <string> # 패키지를 빌드하는 데 사용된 Move 언어의 에디션, 예: "2024.alpha"
flavor = <string> # 패키지를 빌드하는 데 사용된 Move 컴파일러의 플레이버, 예: "sui"
```