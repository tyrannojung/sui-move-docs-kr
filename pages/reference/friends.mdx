---
title: 'Friends | Reference'
description: ''
---

# 더 이상 사용되지 않음: Friends

참고: 이 기능은 [`public(package)`](./functions#visibility)로 대체되었습니다.

`friend` 구문은 현재 module이 신뢰하는 module을 선언하는 데 사용되었습니다. 신뢰하는 module은 현재 module에서 `public(friend)` 가시성을 가진 함수를 호출할 수 있습니다. 함수 가시성에 대한 자세한 내용은 [함수](./functions)의 _가시성_ 섹션을 참조하세요.

## Friend 선언

module은 friend 선언문을 통해 다른 module을 friend로 선언할 수 있으며, 형식은 다음과 같습니다:

- `friend <address::name>` — 아래 예제처럼 정규화된 module 이름을 사용한 friend 선언, 또는

  ```move
  module 0x42::a {
      friend 0x42::b;
  }
  ```

- `friend <module-name-alias>` — module 이름 별칭을 사용한 friend 선언, 여기서 module 별칭은 `use` 문을 통해 도입됩니다.

  ```move
  module 0x42::a {
      use 0x42::b;
      friend b;
  }
  ```

module은 여러 friend 선언을 가질 수 있으며, 모든 friend module의 합집합이 friend 목록을 형성합니다. 아래 예제에서 `0x42::B`와 `0x42::C` 모두 `0x42::A`의 friend로 간주됩니다.

```move
module 0x42::a;

friend 0x42::b;
friend 0x42::c;
```

`use` 문과 달리, `friend`는 module 범위에서만 선언할 수 있고 표현식 블록 범위에서는 선언할 수 없습니다. `friend` 선언은 최상위 구조(예: `use`, `function`, `struct` 등)가 허용되는 모든 곳에 위치할 수 있습니다. 그러나 가독성을 위해 friend 선언을 module 정의의 시작 부분 근처에 배치하는 것이 좋습니다.

### Friend 선언 규칙

Friend 선언은 다음 규칙을 따릅니다:

- module은 자기 자신을 friend로 선언할 수 없습니다.

  ```move
  module 0x42::m { friend Self; // 오류! }
  //                      ^^^^ module 자체를 friend로 선언할 수 없습니다

  module 0x43::m { friend 0x43::M; // 오류! }
  //                      ^^^^^^^ module 자체를 friend로 선언할 수 없습니다
  ```

- Friend module은 컴파일러에 알려져 있어야 합니다

  ```move
  module 0x42::m { friend 0x42::nonexistent; // 오류! }
  //                      ^^^^^^^^^^^^^^^^^ 바인딩되지 않은 module '0x42::nonexistent'
  ```

- Friend module은 같은 계정 주소 내에 있어야 합니다.

  ```move
  module 0x42::m {}

  module 0x42::n { friend 0x42::m; // 오류! }
  //                      ^^^^^^^ 현재 주소 밖의 module을 friend로 선언할 수 없습니다
  ```

- Friend 관계는 순환 module 의존성을 만들 수 없습니다.

  friend 관계에서 순환은 허용되지 않습니다. 예를 들어, `0x2::a`가 `0x2::b`를 friend로, `0x2::b`가 `0x2::c`를 friend로, `0x2::c`가 `0x2::a`를 friend로 하는 관계는 허용되지 않습니다. 더 일반적으로, friend module을 선언하면 현재 module에 대한 의존성이 friend module에 추가됩니다(목적이 friend가 현재 module의 함수를 호출하는 것이기 때문입니다). 해당 friend module이 이미 직접적 또는 간접적으로 사용되고 있다면, 의존성 순환이 생성됩니다.

  ```move
  module 0x2::a {
      use 0x2::c;
      friend 0x2::b;

      public fun a() {
          c::c()
      }
  }

  module 0x2::b {
      friend 0x2::c; // 오류!
  //         ^^^^^^ 이 friend 관계는 의존성 순환을 만듭니다: '0x2::b'는 '0x2::a'의 friend이고 '0x2::a'는 '0x2::c'를 사용하며 '0x2::c'는 '0x2::b'의 friend입니다
  }

  module 0x2::c {
      public fun c() {}
  }
  ```

- module의 friend 목록에는 중복이 포함될 수 없습니다.

  ```move
  module 0x42::a {}

  module 0x42::m {
      use 0x42::a as aliased_a;
      friend 0x42::A;
      friend aliased_a; // 오류!
  //         ^^^^^^^^^ 중복된 friend 선언 '0x42::a'. module의 friend 선언은 고유해야 합니다
  }
  ```