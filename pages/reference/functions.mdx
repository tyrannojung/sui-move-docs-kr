---
title: '함수 | 참조'
description: ''
---

# 함수

함수는 모듈 내부에서 선언되며 모듈의 로직과 동작을 정의합니다. 함수는 다른 함수에서 호출되거나 실행의 진입점으로 재사용될 수 있습니다.

## 선언

함수는 `fun` 키워드 다음에 함수 이름, 타입 매개변수, 매개변수, 반환 타입, 그리고 마지막으로 함수 본문 순으로 선언됩니다.

```text
<visibility>? <entry>? <macro>? fun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <function_body>
```

예를 들어

```move
fun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
```

### 가시성 (Visibility)

모듈 함수는 기본적으로 동일한 모듈 내에서만 호출할 수 있습니다. 이러한 내부(때때로 private이라고 불리는) 함수는 다른 모듈에서 호출하거나 진입점으로 사용할 수 없습니다.

```move
module a::m {
    fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'
    }
}
```

다른 모듈에서 접근을 허용하려면 함수를 `public` 또는 `public(package)`로 선언해야 합니다.
가시성과 관련하여, [`entry`](#entry-modifier) 함수는 실행의 진입점으로 호출될 수 있습니다.

#### `public` 가시성

`public` 함수는 _모든_ 모듈에서 정의된 _모든_ 함수에 의해 호출될 수 있습니다. 다음 예제에서 보듯이, `public` 함수는 다음과 같이 호출될 수 있습니다:

- 동일한 모듈에서 정의된 다른 함수,
- 다른 모듈에서 정의된 함수, 또는
- 실행의 진입점으로서.

```move
module a::m {
    public fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // valid
    }
}
```

실행의 진입점에 대한 자세한 내용은 [아래 섹션](#entry-modifier)을 참조하세요.

#### `public(package)` 가시성

`public(package)` 가시성 수정자는 함수를 사용할 수 있는 위치에 대해 더 많은 제어를 제공하는 `public` 수정자의 더 제한된 형태입니다. `public(package)` 함수는 다음에 의해 호출될 수 있습니다:

- 동일한 모듈에서 정의된 다른 함수, 또는
- 동일한 패키지(동일한 주소)에서 정의된 다른 함수

```move
module a::m {
    public(package) fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module a::n {
    fun calls_m_foo(): u64 {
        a::m::foo() // valid, also in `a`
    }
}

module b::other {
    fun calls_m_foo(): u64 {
        b::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' can only be called from a module in `a`
    }
}
```

#### 사용 중단된 `public(friend)` 가시성

`public(package)`가 추가되기 전에, `public(friend)`는 동일한 패키지의 함수에 대한 제한된 공개 접근을 허용하는 데 사용되었지만, 허용된 모듈 목록은 호출된 모듈에 의해 명시적으로 나열되어야 했습니다. 자세한 내용은 [Friends](./friends)를 참조하세요.

### `entry` 수정자

`public` 함수 외에도, 실행의 진입점으로 사용하고자 하는 일부 함수가 모듈에 있을 수 있습니다. `entry` 수정자는 다른 모듈에 기능을 노출하지 않고도 모듈 함수가 실행을 시작할 수 있도록 설계되었습니다.

본질적으로, `public`과 `entry` 함수의 조합은 모듈의 "main" 함수를 정의하며, Move 프로그램이 실행을 시작할 수 있는 위치를 지정합니다.

그러나 `entry` 함수는 여전히 다른 Move 함수에 의해 호출될 수 있다는 점을 명심하세요. 따라서 Move 프로그램의 시작점 역할을 할 수 있지만, 그 경우에만 제한되지는 않습니다.

예를 들어:

```move
module a::m {
    entry fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid!
}

module a::n {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'
    }
}
```

`entry` 함수는 매개변수와 반환 타입에 제한이 있을 수 있습니다. 하지만 이러한 제한은 Move의 각 개별 배포에 특화되어 있습니다.

[Sui의 `entry` 함수에 대한 문서는 여기에서 찾을 수 있습니다.](https://docs.sui.io/concepts/sui-move-concepts/entry-functions)

더 쉬운 테스트를 가능하게 하기 위해, `entry` 함수는 [`#[test]`와 `#[test_only]`](./unit-testing) 컨텍스트에서 호출될 수 있습니다.

```move
module a::m {
    entry fun foo(): u64 { 0 }
}
module a::m_test {
    #[test]
    fun my_test(): u64 { a::m::foo() } // valid!
    #[test_only]
    fun my_test_helper(): u64 { a::m::foo() } // valid!
}
```

### `macro` 수정자

일반 함수와 달리, `macro` 함수는 런타임에 존재하지 않습니다. 대신, 이러한 함수는 컴파일 중 각 호출 위치에서 인라인으로 대체됩니다. 이러한 `macro` 함수는 이 컴파일 프로세스를 활용하여 고차 _lambda_ 스타일 함수를 인수로 받는 것과 같은 표준 함수 이상의 기능을 제공합니다. 컴파일 중에 확장되는 이러한 람다 인수를 사용하면 함수 본문의 일부를 매크로에 인수로 전달할 수 있습니다. 예를 들어, 루프 본문이 람다로 제공되는 다음의 간단한 루프 매크로를 고려해보세요:

```move
macro fun n_times($n: u64, $body: |u64| -> ()) {
    let n = $n;
    let mut i = 0;
    while (i < n) {
        $body(i);
        i = i + 1;
    }
}

fun example() {
    let mut sum = 0;
    n_times!(10, |x| sum = sum + x );
}
```

자세한 내용은 [매크로](./functions/macros) 챕터를 참조하세요.

### 이름

함수 이름은 문자 `a`부터 `z`로 시작할 수 있습니다. 첫 번째 문자 이후, 함수 이름에는 밑줄 `_`, 문자 `a`부터 `z`, 문자 `A`부터 `Z`, 또는 숫자 `0`부터 `9`가 포함될 수 있습니다.

```move
fun fOO() {}
fun bar_42() {}
fun bAZ_19() {}
```

### 타입 매개변수

이름 다음에, 함수는 타입 매개변수를 가질 수 있습니다

```move
fun id<T>(x: T): T { x }
fun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
```

자세한 내용은 [Move 제네릭](./generics)을 참조하세요.

### 매개변수

함수 매개변수는 로컬 변수 이름 다음에 타입 주석으로 선언됩니다

```move
fun add(x: u64, y: u64): u64 { x + y }
```

이것을 `x`가 타입 `u64`를 가진다고 읽습니다

함수는 매개변수를 전혀 가지지 않아도 됩니다.

```move
fun useless() { }
```

이것은 새로운 또는 빈 데이터 구조를 생성하는 함수에서 매우 일반적입니다

```move
module a::example;

public struct Counter { count: u64 }

fun new_counter(): Counter {
    Counter { count: 0 }
}
```

### 반환 타입

매개변수 다음에, 함수는 반환 타입을 지정합니다.

```move
fun zero(): u64 { 0 }
```

여기서 `: u64`는 함수의 반환 타입이 `u64`임을 나타냅니다.

[튜플](./primitive-types/tuples)을 사용하여, 함수는 여러 값을 반환할 수 있습니다:

```move
fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
```

반환 타입이 지정되지 않으면, 함수는 암시적으로 단위 `()`의 반환 타입을 가집니다. 이러한 함수들은 동일합니다:

```move
fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
```

[튜플 섹션](./primitive-types/tuples)에서 언급했듯이, 이러한 튜플 "값"은 런타임 값으로 존재하지 않습니다. 이는 단위 `()`를 반환하는 함수가 실행 중에 어떤 값도 반환하지 않는다는 것을 의미합니다.

### 함수 본문

함수의 본문은 표현식 블록입니다. 함수의 반환 값은 시퀀스의 마지막 값입니다

```move
fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
```

[반환에 대한 자세한 정보는 아래 섹션](#returning-values)을 참조하세요

표현식 블록에 대한 자세한 정보는 [Move 변수](./variables)를 참조하세요.

### 네이티브 함수 (Native Functions)

일부 함수는 본문이 지정되지 않고, 대신 VM에 의해 본문이 제공됩니다. 이러한 함수는 `native`로 표시됩니다.

VM 소스 코드를 수정하지 않고는 프로그래머가 새로운 네이티브 함수를 추가할 수 없습니다. 또한, `native` 함수는 표준 라이브러리 코드나 주어진 Move 환경에 필요한 기능을 위해 사용되도록 의도되었습니다.

여러분이 보게 될 대부분의 `native` 함수는 `vector`와 같은 표준 라이브러리 코드에 있습니다

```move
module std::vector {
    native public fun length<Element>(v: &vector<Element>): u64;
    ...
}
```

## 호출

함수를 호출할 때, 이름은 별칭을 통해 지정하거나 완전히 정규화된 형태로 지정할 수 있습니다

```move
module a::example {
    public fun zero(): u64 { 0 }
}

module b::other {
    use a::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        a::example::zero();
        example::zero();
        zero();
    }
}
```

함수를 호출할 때, 모든 매개변수에 대해 인수가 제공되어야 합니다.

```move
module a::example {
    public fun takes_none(): u64 { 0 }
    public fun takes_one(x: u64): u64 { x }
    public fun takes_two(x: u64, y: u64): u64 { x + y }
    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}

module b::other {
    fun call_all() {
        a::example::takes_none();
        a::example::takes_one(0);
        a::example::takes_two(0, 1);
        a::example::takes_three(0, 1, 2);
    }
}
```

타입 인수는 지정하거나 추론될 수 있습니다. 두 호출은 동일합니다.

```move
module a::example {
    public fun id<T>(x: T): T { x }
}

module b::other {
    fun call_all() {
        a::example::id(0);
        a::example::id<u64>(0);
    }
}
```

자세한 내용은 [Move 제네릭](./generics)을 참조하세요.

## 값 반환하기

함수의 결과, 즉 "반환 값"은 함수 본문의 최종 값입니다. 예를 들어

```move
fun add(x: u64, y: u64): u64 {
    x + y
}
```

여기서 반환 값은 `x + y`의 결과입니다.

[위에서 언급했듯이](#function-body), 함수의 본문은 [표현식 블록](./variables)입니다. 표현식 블록은 다양한 문장을 순서대로 실행할 수 있으며, 블록의 최종 표현식이 해당 블록의 값이 됩니다

```move
fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
```

여기서 반환 값은 `double_x + double_y`의 결과입니다

### `return` 표현식

함수는 본문이 평가하는 값을 암시적으로 반환합니다. 그러나 함수는 명시적인 `return` 표현식을 사용할 수도 있습니다:

```move
fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
```

이 두 함수는 동일합니다. 약간 더 복잡한 예제에서, 함수는 두 `u64` 값을 빼지만, 두 번째 값이 너무 크면 `0`으로 조기에 반환합니다:

```move
fun safe_sub(x: u64, y: u64): u64 {
    if (y > x) return 0;
    x - y
}
```

이 함수의 본문은 `if (y > x) 0 else x - y`로도 작성될 수 있음을 주목하세요.

그러나 `return`이 정말 빛을 발하는 것은 다른 제어 흐름 구조 깊숙이에서 종료할 때입니다. 이 예제에서, 함수는 벡터를 반복하여 주어진 값의 인덱스를 찾습니다:

```move
use std::vector;
use std::option::{Self, Option};

fun index_of<T>(v: &vector<T>, target: &T): Option<u64> {
    let i = 0;
    let n = vector::length(v);
    while (i < n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
```

인수 없이 `return`을 사용하는 것은 `return ()`의 단축형입니다. 즉, 다음 두 함수는 동일합니다:

```move
fun foo() { return }
fun foo() { return () }
```