---
title: 'Unit Tests | Reference'
description: ''
---

# 유닛 테스트

Move의 유닛 테스트는 Move 소스 언어에서 세 가지 주석을 사용합니다:

- `#[test]`는 함수를 테스트로 표시합니다;
- `#[expected_failure]`는 테스트가 실패할 것으로 예상됨을 표시합니다;
- `#[test_only]`는 모듈 또는 모듈 멤버([`use`](./uses), [함수](./functions),
  [구조체](./structs), 또는 [상수](./constants))를 테스트용으로만 포함될 코드로 표시합니다.

이러한 주석은 모든 가시성을 가진 적절한 형식에 배치할 수 있습니다. 모듈 또는 모듈 멤버가 `#[test_only]` 또는 `#[test]`로 주석 처리되면 테스트용으로 컴파일되지 않는 한 컴파일된 바이트코드에 포함되지 않습니다.

## 테스트 주석

`#[test]` 주석은 매개변수가 없는 함수에만 배치할 수 있습니다. 이 주석은 함수를 유닛 테스트 하네스에서 실행할 테스트로 표시합니다.

```move
#[test] // OK
fun this_is_a_test() { ... }

#[test] // Will fail to compile since the test takes an argument
fun this_is_not_correct(arg: u64) { ... }
```

테스트는 `#[expected_failure]`로도 주석 처리할 수 있습니다. 이 주석은 테스트가 오류를 발생시킬 것으로 예상됨을 표시합니다. `#[expected_failure]` 주석과 함께 사용할 수 있는 여러 옵션이 있어 지정된 조건의 실패만 통과로 표시되도록 할 수 있으며, 이러한 옵션은 [예상 실패](#expected-failures)에 자세히 설명되어 있습니다. `#[test]` 주석을 가진 함수만 #`[expected_failure]`로도 주석 처리할 수 있습니다.

`#[expected_failure]` 주석 사용의 몇 가지 간단한 예는 다음과 같습니다:

```move
#[test]
#[expected_failure]
public fun this_test_will_abort_and_pass() { abort 1 }

#[test]
#[expected_failure]
public fun test_will_error_and_pass() { 1/0; }

#[test] // Will pass since test fails with the expected abort code constant.
#[expected_failure(abort_code = ENotFound)] // ENotFound is a constant defined in the module
public fun test_will_error_and_pass_abort_code() { abort ENotFound }

#[test] // Will fail since test fails with a different error than expected.
#[expected_failure(abort_code = my_module::ENotFound)]
public fun test_will_error_and_fail() { 1/0; }

#[test, expected_failure] // Can have multiple in one attribute. This test will pass.
public fun this_other_test_will_abort_and_pass() { abort 1 }
```

> **참고**: `#[test]` 및 `#[test_only]` 함수는 가시성에 관계없이
> [`entry`](./functions#entry-modifier) 함수도 호출할 수 있습니다.

## 예상 실패

`#[expected_failure]` 주석을 사용하여 다양한 유형의 오류 조건을 지정할 수 있는 여러 가지 방법이 있습니다. 이들은 다음과 같습니다:

### 1. `#[expected_failure(abort_code = <constant>)]`

테스트가 상수를 정의하는 모듈의 지정된 상수 값으로 중단되면 통과하고 그렇지 않으면 실패합니다. 이는 예상되는 테스트 실패를 테스트하는 권장 방법입니다.

> **참고**: `expected_failure` 주석에서 현재 모듈이나 패키지 외부의 상수를 참조할 수 있습니다.

```move
module pkg_addr::other_module {
    const ENotFound: u64 = 1;
    public fun will_abort() {
        abort ENotFound
    }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    const ENotFound: u64 = 1;

    #[test]
    #[expected_failure(abort_code = ENotFound)]
    fun test_will_abort_and_pass() { abort ENotFound }

    #[test]
    #[expected_failure(abort_code = other_module::ENotFound)]
    fun test_will_abort_and_pass() { other_module::will_abort() }

    // FAIL: Will not pass since we are expecting the constant from the wrong module.
    #[test]
    #[expected_failure(abort_code = ENotFound)]
    fun test_will_abort_and_pass() { other_module::will_abort() }
}
```

### 2. `#[expected_failure(arithmetic_error, location = <location>)]`

테스트가 지정된 위치에서 산술 오류(예: 정수 오버플로, 0으로 나누기 등)로 실패할 것으로 예상됨을 지정합니다. `<location>`은 모듈 위치에 대한 유효한 경로여야 합니다(예: `Self` 또는 `my_package::my_module`).

```move
module pkg_addr::other_module {
    public fun will_arith_error() { 1/0; }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    #[test]
    #[expected_failure(arithmetic_error, location = Self)]
    fun test_will_arith_error_and_pass1() { 1/0; }

    #[test]
    #[expected_failure(arithmetic_error, location = pkg_addr::other_module)]
    fun test_will_arith_error_and_pass2() { other_module::will_arith_error() }

    // FAIL: Will fail since the location we expect it the fail at is different from where the test actually failed.
    #[test]
    #[expected_failure(arithmetic_error, location = Self)]
    fun test_will_arith_error_and_fail() { other_module::will_arith_error() }
}
```

### 3. `#[expected_failure(out_of_gas, location = <location>)]`

테스트가 지정된 위치에서 가스 부족 오류로 실패할 것으로 예상됨을 지정합니다. `<location>`은 모듈 위치에 대한 유효한 경로여야 합니다(예: `Self` 또는 `my_package::my_module`).

```move
module pkg_addr::other_module {
    public fun will_oog() { loop {} }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    #[test]
    #[expected_failure(out_of_gas, location = Self)]
    fun test_will_oog_and_pass1() { loop {} }

    #[test]
    #[expected_failure(arithmetic_error, location = pkg_addr::other_module)]
    fun test_will_oog_and_pass2() { other_module::will_oog() }

    // FAIL: Will fail since the location we expect it the fail at is different from where
    // the test actually failed.
    #[test]
    #[expected_failure(out_of_gas, location = Self)]
    fun test_will_oog_and_fail() { other_module::will_oog() }
}
```

### 4. `#[expected_failure(vector_error, minor_status = <u64_opt>, location = <location>)]`

테스트가 지정된 위치에서 주어진 `minor_status`(제공된 경우)로 벡터 오류로 실패할 것으로 예상됨을 지정합니다. `<location>`은 모듈 위치에 대한 유효한 경로여야 합니다(예: `Self` 또는 `my_package::my_module`). `<u64_opt>`는 벡터 오류의 부 상태를 지정하는 선택적 매개변수입니다. 지정하지 않으면 테스트가 모든 부 상태로 실패할 때 통과합니다. 지정하면 테스트가 지정된 부 상태의 벡터 오류로 실패할 때만 통과합니다.

```move
module pkg_addr::other_module {
    public fun vector_borrow_empty() {
        &vector<u64>[][1];
    }
}

module pkg_addr::my_module {
    #[test]
    #[expected_failure(vector_error, location = Self)]
    fun vector_abort_same_module() {
        vector::borrow(&vector<u64>[], 1);
    }

    #[test]
    #[expected_failure(vector_error, location = pkg_addr::other_module)]
    fun vector_abort_same_module() {
        other_module::vector_borrow_empty();
    }

    // Can specify minor statues (i.e., vector-specific error codes) to expect.
    #[test]
    #[expected_failure(vector_error, minor_status = 1, location = Self)]
    fun native_abort_good_right_code() {
        vector::borrow(&vector<u64>[], 1);
    }

    // FAIL: correct error, but wrong location.
    #[test]
    #[expected_failure(vector_error, location = pkg_addr::other_module)]
    fun vector_abort_same_module() {
        other_module::vector_borrow_empty();
    }

    // FAIL: correct error and location but the minor status differs so this test will fail.
    #[test]
    #[expected_failure(vector_error, minor_status = 0, location = Self)]
    fun vector_abort_wrong_minor_code() {
        vector::borrow(&vector<u64>[], 1);
    }
}
```

### 5. `#[expected_failure]`

테스트가 _모든_ 오류 코드로 중단되면 통과합니다. 예상되는 테스트 실패를 주석 처리하는 데 이것을 사용할 때는 **_매우 주의해야_** 하며, 항상 위에 설명된 방법 중 하나를 선호해야 합니다. 이러한 유형의 주석 예는 다음과 같습니다:

```move
#[test]
#[expected_failure]
fun test_will_abort_and_pass1() { abort 1 }

#[test]
#[expected_failure]
fun test_will_arith_error_and_pass2() { 1/0; }
```

## 테스트 전용 주석

모듈과 그 멤버들은 테스트 전용으로 선언될 수 있습니다. 항목이 `#[test_only]`로 주석 처리되면 해당 항목은 테스트 모드로 컴파일될 때만 컴파일된 Move 바이트코드에 포함됩니다. 또한 테스트 모드 외부에서 컴파일할 때 `#[test_only]` 모듈의 비테스트 `use`는 컴파일 중 오류를 발생시킵니다.

> **참고**: `#[test_only]`로 주석 처리된 함수는 테스트 코드에서만 호출할 수 있지만,
> 그 자체는 테스트가 아니며 유닛 테스트 프레임워크에서 테스트로 실행되지 않습니다.

```move
#[test_only] // test only attributes can be attached to modules
module abc { ... }

#[test_only] // test only attributes can be attached to constants
const MY_ADDR: address = @0x1;

#[test_only] // .. to uses
use pkg_addr::some_other_module;

#[test_only] // .. to structs
public struct SomeStruct { ... }

#[test_only] // .. and functions. Can only be called from test code, but this is _not_ a test!
fun test_only_function(...) { ... }
```

## 유닛 테스트 실행

Move 패키지의 유닛 테스트는 [`sui move test` 명령](./packages)으로 실행할 수 있습니다.

테스트를 실행할 때 모든 테스트는 `PASS`, `FAIL` 또는 `TIMEOUT` 중 하나가 됩니다. 테스트 케이스가 실패하면 가능한 경우 실패를 야기한 함수 이름과 함께 실패 위치가 보고됩니다. 아래에서 이에 대한 예를 볼 수 있습니다.

테스트가 단일 테스트에 대해 실행할 수 있는 최대 명령어 수를 초과하면 타임아웃으로 표시됩니다. 이 한계는 아래 옵션을 사용하여 변경할 수 있습니다. 또한 테스트 결과는 항상 결정적이지만 테스트는 기본적으로 병렬로 실행되므로 옵션을 통해 구성할 수 있는 하나의 스레드로만 실행하지 않는 한 테스트 실행에서 테스트 결과의 순서는 비결정적입니다.

위에서 언급한 옵션은 테스트를 미세 조정하고 실패한 테스트를 디버깅하는 데 도움이 되는 여러 옵션 중 두 가지입니다. 사용 가능한 모든 옵션과 각 옵션이 수행하는 작업에 대한 설명을 보려면 `sui move test` 명령에 `--help` 플래그를 전달하세요:

```
$ sui move test --help
```

## 예제

유닛 테스트 기능 중 일부를 사용하는 간단한 모듈이 다음 예제에 표시됩니다:

먼저 빈 패키지를 만들고 해당 디렉토리로 이동합니다:

```bash
$ sui move new test_example; cd test_example
```

다음으로 `sources` 디렉토리 아래에 다음 모듈을 추가합니다:

```move
// filename: sources/my_module.move
module test_example::my_module;

public struct Wrapper(u64)

const ECoinIsZero: u64 = 0;

public fun make_sure_non_zero_coin(coin: Wrapper): Wrapper {
    assert!(coin.0 > 0, ECoinIsZero);
    coin
}

#[test]
fun make_sure_non_zero_coin_passes() {
    let coin = Wrapper(1);
    let Wrapper(_) = make_sure_non_zero_coin(coin);
}

#[test]
// Or #[expected_failure] if we don't care about the abort code
#[expected_failure(abort_code = ECoinIsZero)]
fun make_sure_zero_coin_fails() {
    let coin = Wrapper(0);
    let Wrapper(_) = make_sure_non_zero_coin(coin);
}

#[test_only] // test only helper function
fun make_coin_zero(coin: &mut Wrapper) {
    coin.0 = 0;
}

#[test]
#[expected_failure(abort_code = ECoinIsZero)]
fun make_sure_zero_coin_fails2() {
    let mut coin = Wrapper(10);
    coin.make_coin_zero();
    let Wrapper(_) = make_sure_non_zero_coin(coin);
}
```

### 테스트 실행

그런 다음 `move test` 명령으로 이러한 테스트를 실행할 수 있습니다:

```bash
$ sui move test
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails2
Test result: OK. Total tests: 3; passed: 3; failed: 0
```

### 테스트 플래그 사용

#### 실행할 특정 테스트 전달

`sui move test <str>`로 특정 테스트 또는 테스트 세트를 실행할 수 있습니다. 이는 완전한 정규 이름에 `<str>`이 포함된 테스트만 실행합니다. 예를 들어 이름에 `"non_zero"`가 있는 테스트만 실행하려는 경우:

```bash
$ sui move test non_zero
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

#### `-i <bound>` 또는 `--gas_used <bound>`

이는 하나의 테스트에 소비할 수 있는 가스 양을 `<bound>`로 제한합니다:

```bash
$ sui move test -i 0
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ TIMEOUT ] 0x0::my_module::make_sure_non_zero_coin_passes
[ FAIL    ] 0x0::my_module::make_sure_zero_coin_fails
[ FAIL    ] 0x0::my_module::make_sure_zero_coin_fails2

Test failures:

Failures in 0x0::my_module:

┌── make_sure_non_zero_coin_passes ──────
│ Test timed out
└──────────────────


┌── make_sure_zero_coin_fails ──────
│ error[E11001]: test failure
│    ┌─ ./sources/my_module.move:22:27
│    │
│ 21 │     fun make_sure_zero_coin_fails() {
│    │         ------------------------- In this function in 0x0::my_module
│ 22 │         let coin = MyCoin(0);
│    │                           ^ Test did not error as expected. Expected test to abort with code 0 <SNIP>
│
│
└──────────────────


┌── make_sure_zero_coin_fails2 ──────
│ error[E11001]: test failure
│    ┌─ ./sources/my_module.move:34:31
│    │
│ 33 │     fun make_sure_zero_coin_fails2() {
│    │         -------------------------- In this function in 0x0::my_module
│ 34 │         let mut coin = MyCoin(10);
│    │                               ^^ Test did not error as expected. Expected test to abort with code 0 <SNIP>
│
│
└──────────────────

Test result: FAILED. Total tests: 3; passed: 0; failed: 3
```

#### `-s` 또는 `--statistics`

이러한 플래그를 사용하면 실행된 테스트에 대한 통계를 수집하고 각 테스트에 사용된 런타임과 가스를 보고할 수 있습니다. 추가로 `csv`(`sui move test -s csv`)를 추가하여 가스 사용량을 csv 출력 형식으로 얻을 수 있습니다. 예를 들어, 위 예제의 테스트에 대한 통계를 보고 싶다면:

```bash
$ sui move test -s
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails2

Test Statistics:

┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐
│                   Test Name                    │    Time    │         Gas Used          │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x0::my_module::make_sure_non_zero_coin_passes │   0.001    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x0::my_module::make_sure_zero_coin_fails      │   0.001    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x0::my_module::make_sure_zero_coin_fails2     │   0.001    │             1             │
└────────────────────────────────────────────────┴────────────┴───────────────────────────┘

Test result: OK. Total tests: 3; passed: 3; failed: 0
```
