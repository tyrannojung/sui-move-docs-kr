---
title: 'Constants | Reference'
description: ''
---

# 상수

상수는 `module` 내부에서 공유되는 정적 값에 이름을 부여하는 방법입니다.

상수의 값은 컴파일 시점에 알려져야 합니다. 상수의 값은 컴파일된 module에 저장됩니다.
그리고 상수가 사용될 때마다 해당 값의 새로운 복사본이 만들어집니다.

## 선언

상수 선언은 `const` 키워드로 시작하고, 그 다음에 이름, 타입, 값이 옵니다.

```text
const <name>: <type> = <expression>;
```

예를 들어

```move
module a::example;

const MY_ADDRESS: address = @a;

public fun permissioned(addr: address) {
    assert!(addr == MY_ADDRESS, 0);
}
```

## 명명 규칙

상수는 대문자 `A`부터 `Z`로 시작해야 합니다. 첫 글자 이후, 상수 이름은
밑줄 `_`, 소문자 `a`부터 `z`, 대문자 `A`부터 `Z`, 또는 숫자 `0`부터 `9`를 포함할 수 있습니다.

```move
const FLAG: bool = false;
const EMyErrorCode: u64 = 0;
const ADDRESS_42: address = @0x42;
```

상수에 소문자 `a`부터 `z`를 사용할 수 있지만,
[일반적인 스타일 가이드라인](./coding-conventions)은 대문자 `A`부터 `Z`만 사용하고,
각 단어 사이에 밑줄 `_`을 사용하는 것입니다. 에러 코드의 경우, `E`를 접두사로 사용하고
나머지 이름은 대문자 카멜 케이스(파스칼 케이스라고도 함)를 사용합니다. `EMyErrorCode`에서 볼 수 있듯이요.

`A`부터 `Z`로 시작해야 한다는 현재의 명명 제한은 향후 언어 기능을 위한 여지를 남겨두기 위한 것입니다.

## 가시성

`public` 또는 `public(package)` 상수는 현재 지원되지 않습니다. `const` 값은 선언된 module에서만
사용할 수 있습니다. 그러나 편의를 위해 [단위 테스트 속성](./unit-testing)에서는 module 간에
사용할 수 있습니다.

## 유효한 표현식

현재 상수는 원시 타입 `bool`, `u8`, `u16`, `u32`, `u64`, `u128`,
`u256`, `address`, 그리고 `vector<T>`로 제한됩니다. 여기서 `T`는 상수에 유효한 타입입니다.

### 값

일반적으로 `const`는 해당 타입의 간단한 값이나 리터럴이 할당됩니다. 예를 들어

```move
const MY_BOOL: bool = false;
const MY_ADDRESS: address = @0x70DD;
const BYTES: vector<u8> = b"hello world";
const HEX_BYTES: vector<u8> = x"DEADBEEF";
```

### 복잡한 표현식

리터럴 외에도, 컴파일러가 컴파일 시점에 표현식을 값으로 축소할 수 있는 한,
상수는 더 복잡한 표현식을 포함할 수 있습니다.

현재 동등 연산, 모든 불리언 연산, 모든 비트 연산, 그리고 모든 산술 연산을 사용할 수 있습니다.

```move
const RULE: bool = true && false;
const CAP: u64 = 10 * 100 + 1;
const SHIFTY: u8 = {
    (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)
};
const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
const REM: u256 =
    57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;
const EQUAL: bool = 1 == 1;
```

연산이 런타임 예외를 발생시킬 경우, 컴파일러는 상수의 값을 생성할 수 없다는 오류를 발생시킵니다.

```move
const DIV_BY_ZERO: u64 = 1 / 0; // ERROR!
const SHIFT_BY_A_LOT: u64 = 1 << 100; // ERROR!
const NEGATIVE_U64: u64 = 0 - 1; // ERROR!
```

또한 상수는 동일한 module 내의 다른 상수를 참조할 수 있습니다.

```move
const BASE: u8 = 4;
const SQUARE: u8 = BASE * BASE;
```

하지만 상수 정의에서 순환 참조가 발생하면 오류가 발생한다는 점에 주의하세요.

```move
const A: u16 = B + 1;
const B: u16 = A + 1; // ERROR!
```
