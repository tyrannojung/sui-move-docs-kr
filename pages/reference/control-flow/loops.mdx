---
title: 'Loops | Reference'
description: ''
---

# Move의 루프 구조

많은 프로그램은 값에 대한 반복이 필요하며, Move는 이러한 상황에서 코드를 작성할 수 있도록 `while`과 `loop` 형식을 제공합니다. 또한 실행 중에 `break`(루프를 종료)와 `continue`(이번 반복의 나머지를 건너뛰고 제어 흐름 구조의 맨 위로 돌아가기)를 사용하여 이러한 루프의 제어 흐름을 수정할 수도 있습니다.

## `while` 루프

`while` 구조는 조건(`bool` 타입의 표현식)이 `false`로 평가될 때까지 본문(unit 타입의 표현식)을 반복합니다.

다음은 `1`부터 `n`까지의 숫자의 합을 계산하는 간단한 `while` 루프의 예입니다:

```move
fun sum(n: u64): u64 {
    let mut sum = 0;
    let mut i = 1;
    while (i <= n) {
        sum = sum + i;
        i = i + 1
    };

    sum
}
```

무한 `while` 루프도 허용됩니다:

```move
fun foo() {
    while (true) { }
}
```

### `while` 루프 내부에서 `break` 사용하기

Move에서 `while` 루프는 `break`를 사용하여 조기에 종료할 수 있습니다. 예를 들어, 벡터에서 값의 위치를 찾고 있고, 찾으면 `break`하고 싶다고 가정해 봅시다:

```move
fun find_position(values: &vector<u64>, target_value: u64): Option<u64> {
    let size = vector::length(values);
    let mut i = 0;
    let mut found = false;

    while (i < size) {
        if (vector::borrow(values, i) == &target_value) {
            found = true;
            break
        };
        i = i + 1
    };

    if (found) {
        option::some(i)
    } else {
        option::none<u64>()
    }
}
```

여기서 빌린 벡터 값이 우리의 대상 값과 같으면 `found` 플래그를 `true`로 설정한 다음 `break`를 호출하여 프로그램이 루프를 종료하도록 합니다.

마지막으로, `while` 루프의 `break`는 값을 가질 수 없다는 점에 유의하세요: `while` 루프는 항상 단위 타입 `()`을 반환하므로 `break`도 마찬가지입니다.

### `while` 루프 내부에서 `continue` 사용하기

`break`와 유사하게, Move의 `while` 루프는 `continue`를 호출하여 루프 본문의 일부를 건너뛸 수 있습니다. 이를 통해 다음 예제와 같이 조건이 충족되지 않으면 계산의 일부를 건너뛸 수 있습니다:

```move
fun sum_even(values: &vector<u64>): u64 {
    let size = vector::length(values);
    let mut i = 0;
    let mut even_sum = 0;

    while (i < size) {
        let number = *vector::borrow(values, i);
        i = i + 1;
        if (number % 2 == 1) continue;
        even_sum = even_sum + number;
    };
    even_sum
}
```

이 코드는 제공된 벡터를 반복합니다. 각 항목에 대해, 해당 항목이 짝수이면 `even_sum`에 추가합니다. 그렇지 않으면 `continue`를 호출하여 합계 연산을 건너뛰고 `while` 루프 조건 검사로 돌아갑니다.

## `loop` 표현식

`loop` 표현식은 `break`에 도달할 때까지 루프 본문(`()` 타입의 표현식)을 반복합니다:

```move
fun sum(n: u64): u64 {
    let mut sum = 0;
    let mut i = 1;

    loop {
       i = i + 1;
       if (i >= n) break;
       sum = sum + i;
    };

    sum
}
```

`break`가 없으면 루프는 영원히 계속됩니다. 아래 예제에서 `loop`에 `break`가 없기 때문에 프로그램은 영원히 실행됩니다:

```move
fun foo() {
    let mut i = 0;
    loop { i = i + 1 }
}
```

다음은 `loop`를 사용하여 `sum` 함수를 작성하는 예제입니다:

```move
fun sum(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i > n) break;
        sum = sum + i
    };

    sum
}
```

### `loop`에서 값과 함께 `break` 사용하기

항상 `()`를 반환하는 `while` 루프와 달리, `loop`는 `break`를 사용하여 값을 반환할 수 있습니다. 그렇게 하면 전체 `loop` 표현식이 해당 타입의 값으로 평가됩니다. 예를 들어, 위의 `find_position`을 `loop`와 `break`를 사용하여 다시 작성하여 찾으면 즉시 인덱스를 반환할 수 있습니다:

```move
fun find_position(values: &vector<u64>, target_value: u64): Option<u64> {
    let size = vector::length(values);
    let mut i = 0;

    loop {
        if (vector::borrow(values, i) == &target_value) {
            break option::some(i)
        } else if (i >= size) {
            break option::none()
        };
        i = i + 1;
    }
}
```

이 루프는 옵션 결과와 함께 break되고, 함수 본문의 마지막 표현식으로서 해당 값을 최종 함수 결과로 생성합니다.

### `loop` 표현식 내부에서 `continue` 사용하기

예상할 수 있듯이, `continue`는 `loop` 내부에서도 사용할 수 있습니다. 다음은 `while` 대신 `break`와 `continue`가 있는 `loop`를 사용하여 이전 `sum_even` 함수를 다시 작성한 것입니다.

```move
fun sum_even(values: &vector<u64>): u64 {
    let size = vector::length(values);
    let mut i = 0;
    let mut even_sum = 0;

    loop {
        if (i >= size) break;
        let number = *vector::borrow(values, i);
        i = i + 1;
        if (number % 2 == 1) continue;
        even_sum = even_sum + number;
    };
    even_sum
}
```

## `while`과 `loop`의 타입

Move에서 루프는 타입이 지정된 표현식입니다. `while` 표현식은 항상 `()` 타입을 가집니다.

```move
let () = while (i < 10) { i = i + 1 };
```

`loop`가 `break`를 포함하면, 표현식은 break의 타입을 가집니다. 값이 없는 break는 단위 타입 `()`을 가집니다.

```move
(loop { if (i < 10) i = i + 1 else break }: ());
let () = loop { if (i < 10) i = i + 1 else break };

let x: u64 = loop { if (i < 10) i = i + 1 else break 5 };
let x: u64 = loop { if (i < 10) { i = i + 1; continue} else break 5 };
```

또한 루프에 여러 개의 break가 포함되어 있으면 모두 동일한 타입을 반환해야 합니다:

```move
// 유효하지 않음 -- 첫 번째 break는 ()를 반환하고, 두 번째는 5를 반환합니다
let x: u64 = loop { if (i < 10) break else break 5 };
```

`loop`에 `break`가 없으면, `loop`는 `return`, `abort`, `break`, `continue`와 마찬가지로 어떤 타입이든 가질 수 있습니다.

```move
(loop (): u64);
(loop (): address);
(loop (): &vector<vector<u8>>);
```

중첩된 루프에서 벗어나는 것과 같이 더 정밀한 제어 흐름이 필요한 경우, 다음 장에서 Move의 레이블이 지정된 제어 흐름 사용을 소개합니다.