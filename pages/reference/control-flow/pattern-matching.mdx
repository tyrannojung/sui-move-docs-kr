---
title: 'Pattern Matching | Reference'
description: ''
---

# 패턴 매칭

`match` 표현식은 값을 일련의 패턴과 비교한 다음 먼저 일치하는 패턴에 따라 코드를 실행할 수 있게 하는 강력한 제어 구조입니다. 패턴은 단순한 리터럴부터 복잡하고 중첩된 구조체 및 열거형 정의까지 다양할 수 있습니다. `bool` 타입의 테스트 표현식을 기반으로 제어 흐름을 변경하는 `if` 표현식과 달리, `match` 표현식은 모든 타입의 값에 대해 작동하며 여러 분기 중 하나를 선택합니다.

`match` 표현식은 Move 값뿐만 아니라 가변 또는 불변 참조와도 일치시킬 수 있으며, 그에 따라 하위 패턴을 바인딩합니다.

예를 들어:

```move
fun run(x: u64): u64 {
    match (x) {
        1 => 2,
        2 => 3,
        x => x,
    }
}

run(1); // 2를 반환
run(2); // 3을 반환
run(3); // 3을 반환
run(0); // 0을 반환
```

## `match` 구문

`match`는 표현식과 쉼표로 구분된 비어있지 않은 일련의 _매치 암(match arms)_을 받습니다.

각 매치 암은 패턴(`p`), 선택적 가드(`if (g)` 여기서 `g`는 `bool` 타입의 표현식), 화살표(`=>`), 그리고 패턴이 일치할 때 실행할 암 표현식(`e`)으로 구성됩니다.
예를 들어,

```move
match (expression) {
    pattern1 if (guard_expression) => expression1,
    pattern2 => expression2,
    pattern3 => { expression3, expression4, ... },
}
```

매치 암은 위에서 아래로 순서대로 검사되며, 일치하는 첫 번째 패턴(가드 표현식이 있는 경우 `true`로 평가되는)이 실행됩니다.

`match` 내의 일련의 매치 암은 완전해야 한다는 점에 유의하세요. 즉, 매치되는 타입의 모든 가능한 값이 `match`의 패턴 중 하나에 의해 포함되어야 합니다. 일련의 매치 암이 완전하지 않으면 컴파일러가 오류를 발생시킵니다.

## 패턴 구문

패턴은 값이 패턴과 같고, 변수와 와일드카드(예: `x`, `y`, `_`, 또는 `..`)가 모든 것과 "같다"면 값과 일치합니다.

패턴은 값을 매치하는 데 사용됩니다. 패턴은 다음과 같을 수 있습니다:

| 패턴              | 설명                                                            |
| -------------------- | ---------------------------------------------------------------------- |
| 리터럴              | 리터럴 값, 예: `1`, `true`, `@0x1`                           |
| 상수             | 상수 값, 예: `MyConstant`                                   |
| 변수             | 변수, 예: `x`, `y`, `z`                                        |
| 와일드카드             | 와일드카드, 예: `_`                                                  |
| 생성자          | 생성자 패턴, 예: `MyStruct { x, y }`, `MyEnum::Variant(x)` |
| At-패턴           | At-패턴, 예: `x @ MyEnum::Variant(..)`                         |
| Or-패턴           | Or-패턴, 예: `MyEnum::Variant(..) \| MyEnum::OtherVariant(..)` |
| 다중 항수 와일드카드 | 다중 항수 와일드카드, 예: `MyEnum::Variant(..)`                    |
| 가변 바인딩      | 가변 바인딩 패턴, 예: `mut x`                               |

Move의 패턴은 다음과 같은 문법을 가집니다:

```bnf
pattern = <literal>
        | <constant>
        | <variable>
        | _
        | C { <variable> : inner-pattern ["," <variable> : inner-pattern]* } // C는 구조체 또는 열거형 변형
        | C ( inner-pattern ["," inner-pattern]* ... )                       // C는 구조체 또는 열거형 변형
        | C                                                                  // C는 열거형 변형
        | <variable> @ top-level-pattern
        | pattern | pattern
        | mut <variable>
inner-pattern = pattern
              | ..     // 다중 항수 와일드카드
```

패턴의 몇 가지 예는 다음과 같습니다:

```move
// 리터럴 패턴
1

// 상수 패턴
MyConstant

// 변수 패턴
x

// 와일드카드 패턴
_

// 필드 `1`과 `true`를 가진 `MyEnum::Variant`와 일치하는 생성자 패턴
MyEnum::Variant(1, true)

// 필드 `1`을 가진 `MyEnum::Variant`와 일치하고 두 번째 필드의 값을 `x`에 바인딩하는 생성자 패턴
MyEnum::Variant(1, x)

// `MyEnum::Variant` 변형 내의 여러 필드와 일치하는 다중 항수 와일드카드 패턴
MyEnum::Variant(..)

// `MyStruct`의 `x` 필드와 일치하고 `y` 필드를 `other_variable`에 바인딩하는 생성자 패턴
MyStruct { x, y: other_variable }

// `MyEnum::Variant`와 일치하고 전체 값을 `x`에 바인딩하는 at-패턴
x @ MyEnum::Variant(..)

// `MyEnum::Variant` 또는 `MyEnum::OtherVariant`와 일치하는 or-패턴
MyEnum::Variant(..) | MyEnum::OtherVariant(..)

// 위의 or-패턴과 동일하지만 명시적인 와일드카드 사용
MyEnum::Variant(_, _) | MyEnum::OtherVariant(_, _)

// `MyEnum::Variant` 또는 `MyEnum::OtherVariant`와 일치하고 u64 필드를 `x`에 바인딩하는 or-패턴
MyEnum::Variant(x, _) | MyEnum::OtherVariant(_, x)

// `OtherEnum::V`와 일치하고 내부 `MyEnum`이 `MyEnum::Variant`인 경우의 생성자 패턴
OtherEnum::V(MyEnum::Variant(..))
```

### 패턴과 변수

변수를 포함하는 패턴은 매치 대상 또는 매치되는 대상 하위 구성 요소에 변수를 바인딩합니다. 이러한 변수는 매치 가드 표현식이나 매치 암의 오른쪽에서 사용할 수 있습니다. 예를 들어:

```move
public struct Wrapper(u64)

fun add_under_wrapper_unless_equal(wrapper: Wrapper, x: u64): u64 {
    match (wrapper) {
        Wrapper(y) if (y == x) => Wrapper(y),
        Wrapper(y) => y + x,
    }
}
add_under_wrapper_unless_equal(Wrapper(1), 2); // Wrapper(3)을 반환
add_under_wrapper_unless_equal(Wrapper(2), 3); // Wrapper(5)를 반환
add_under_wrapper_unless_equal(Wrapper(3), 3); // Wrapper(3)을 반환
```

### 패턴 결합하기

패턴은 중첩될 수 있지만, or 연산자(`|`)를 사용하여 결합할 수도 있습니다. 예를 들어,
`p1 | p2`는 패턴 `p1` 또는 `p2`가 대상과 일치하면 성공합니다. 이 패턴은 최상위 패턴이나 다른 패턴 내의 하위 패턴으로 어디에나 나타날 수 있습니다.

```move
public enum MyEnum has drop {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

fun test_or_pattern(x: u64): u64 {
    match (x) {
        MyEnum::Variant(1 | 2 | 3, true) | MyEnum::OtherVariant(true, 1 | 2 | 3) => 1,
        MyEnum::Variant(8, true) | MyEnum::OtherVariant(_, 6 | 7) => 2,
        _ => 3,
    }
}

test_or_pattern(MyEnum::Variant(3, true)); // 1을 반환
test_or_pattern(MyEnum::OtherVariant(true, 2)); // 1을 반환
test_or_pattern(MyEnum::Variant(8, true)); // 2를 반환
test_or_pattern(MyEnum::OtherVariant(false, 7)); // 2를 반환
test_or_pattern(MyEnum::OtherVariant(false, 80)); // 3을 반환
```

### 일부 패턴에 대한 제한 사항

`mut`와 `..` 패턴은 언제, 어디서, 어떻게 사용할 수 있는지에 대한 특정 조건이 있으며, 이는 [특정 패턴에 대한 제한 사항](#limitations-on-specific-patterns)에 자세히 설명되어 있습니다. 높은 수준에서, `mut` 수정자는 변수 패턴에만 사용할 수 있고, `..` 패턴은 생성자 패턴 내에서 한 번만 사용할 수 있으며 최상위 패턴으로는 사용할 수 없습니다.

다음은 `..` 패턴의 _잘못된_ 사용 예입니다. 최상위 패턴으로 사용되었기 때문입니다:

```move
match (x) {
    .. => 1,
    // 오류: `..` 패턴은 생성자 패턴 내에서만 사용할 수 있습니다
}

match (x) {
    MyStruct(.., ..) => 1,
    // 오류:    ^^  `..` 패턴은 생성자 패턴 내에서 한 번만 사용할 수 있습니다
}
```

### 패턴 타이핑

패턴은 표현식이 아니지만 그럼에도 불구하고 타입이 지정됩니다. 이는 패턴의 타입이 매치하는 값의 타입과 일치해야 함을 의미합니다. 예를 들어, 패턴 `1`은 정수 타입을 가지고, 패턴 `MyEnum::Variant(1, true)`는 타입 `MyEnum`을 가지며, 패턴 `MyStruct { x, y }`는 타입 `MyStruct`를 가지고, `OtherStruct<bool> { x: true, y: 1}`는 타입 `OtherStruct<bool>`을 가집니다. 매치의 패턴 타입과 다른 표현식을 매치하려고 하면 타입 오류가 발생합니다. 예를 들어:

```move
match (1) {
    // `true` 리터럴 패턴은 `bool` 타입이므로 이는 타입 오류입니다.
    true => 1,
    // 타입 오류: u64 타입을 예상했지만 bool을 찾았습니다
    _ => 2,
}
```

유사하게, `MyEnum`과 `MyStruct`는 다른 타입이므로 다음도 타입 오류가 발생합니다:

```move
match (MyStruct { x: 0, y: 0 }) {
    MyEnum::Variant(..) => 1,
    // 타입 오류: MyEnum 타입을 예상했지만 MyStruct를 찾았습니다
}
```

## 매칭

패턴 매칭의 구체적인 내용과 값이 패턴과 "일치"한다는 것이 무엇을 의미하는지 살펴보기 전에, 개념에 대한 직관을 제공하기 위해 몇 가지 예를 살펴보겠습니다.

```move
fun test_lit(x: u64): u8 {
    match (x) {
        1 => 2,
        2 => 3,
        _ => 4,
    }
}
test_lit(1); // 2를 반환
test_lit(2); // 3을 반환
test_lit(3); // 4를 반환
test_lit(10); // 4를 반환

fun test_var(x: u64): u64 {
    match (x) {
        y => y,
    }
}
test_var(1); // 1을 반환
test_var(2); // 2를 반환
test_var(3); // 3을 반환
...

const MyConstant: u64 = 10;
fun test_constant(x: u64): u64 {
    match (x) {
        MyConstant => 1,
        _ => 2,
    }
}
test_constant(MyConstant); // 1을 반환
test_constant(10); // 1을 반환
test_constant(20); // 2를 반환

fun test_or_pattern(x: u64): u64 {
    match (x) {
        1 | 2 | 3 => 1,
        4 | 5 | 6 => 2,
        _ => 3,
    }
}
test_or_pattern(3); // 1을 반환
test_or_pattern(5); // 2를 반환
test_or_pattern(70); // 3을 반환

fun test_or_at_pattern(x: u64): u64 {
    match (x) {
        x @ (1 | 2 | 3) => x + 1,
        y @ (4 | 5 | 6) => y + 2,
        z => z + 3,
    }
}
test_or_pattern(2); // 3을 반환
test_or_pattern(5); // 7을 반환
test_or_pattern(70); // 73을 반환
```

이러한 예제에서 가장 중요한 점은 값이 패턴과 같으면 패턴이 값과 일치하고, 와일드카드/변수 패턴은 모든 것과 일치한다는 것입니다. 이는 리터럴, 변수, 상수에 해당합니다. 예를 들어, `test_lit` 함수에서 값 `1`은 패턴 `1`과 일치하고, 값 `2`는 패턴 `2`와 일치하며, 값 `3`은 와일드카드 `_`와 일치합니다. 유사하게, `test_var` 함수에서 값 `1`과 값 `2` 모두 패턴 `y`와 일치합니다.

변수 `x`는 모든 값과 일치(또는 "같음")하고, 와일드카드 `_`는 모든 값과 일치합니다(하지만 하나의 값만). Or-패턴은 논리적 OR과 같으며, 값이 or-패턴의 패턴 중 하나와 일치하면 패턴과 일치하므로 `p1 | p2 | p3`는 "p1, 또는 p2, 또는 p3와 일치"로 읽어야 합니다.

### 생성자 매칭

패턴 매칭에는 생성자 패턴의 개념이 포함됩니다. 이러한 패턴을 사용하면 구조체와 열거형 모두 깊숙이 검사하고 액세스할 수 있으며, 패턴 매칭의 가장 강력한 부분 중 하나입니다. 생성자 패턴은 변수 바인딩과 결합되어 구조별로 값을 매치하고 매치 암의 오른쪽에서 사용하기 위해 관심 있는 값의 부분을 추출할 수 있습니다.

다음을 살펴보세요:

```move
fun f(x: MyEnum) {
    match (x) {
        MyEnum::Variant(1, true) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        MyEnum::Variant(..) => 3,
        MyEnum::OtherVariant(..) => 4,
}
f(MyEnum::Variant(1, true)); // 1을 반환
f(MyEnum::Variant(2, true)); // 3을 반환
f(MyEnum::OtherVariant(false, 3)); // 2를 반환
f(MyEnum::OtherVariant(true, 3)); // 2를 반환
f(MyEnum::OtherVariant(true, 2)); // 4를 반환
```

이는 "`x`가 필드 `1`과 `true`를 가진 `MyEnum::Variant`이면 `1`을 반환합니다. 첫 번째 필드에 대한 임의의 값과 두 번째에 대해 `3`을 가진 `MyEnum::OtherVariant`이면 `2`를 반환합니다. 임의의 필드를 가진 `MyEnum::Variant`이면 `3`을 반환합니다. 마지막으로, 임의의 필드를 가진 `MyEnum::OtherVariant`이면 `4`를 반환합니다"라고 말하고 있습니다.

패턴을 중첩할 수도 있습니다. 따라서 이전 `MyEnum::Variant`에서 1만 매치하는 대신 1, 2 또는 10을 매치하려면 or-패턴으로 이를 수행할 수 있습니다:

```move
fun f(x: MyEnum) {
    match (x) {
        MyEnum::Variant(1 | 2 | 10, true) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        MyEnum::Variant(..) => 3,
        MyEnum::OtherVariant(..) => 4,
}
f(MyEnum::Variant(1, true)); // 1을 반환
f(MyEnum::Variant(2, true)); // 1을 반환
f(MyEnum::Variant(10, true)); // 1을 반환
f(MyEnum::Variant(10, false)); // 3을 반환
```

### Ability 제약

또한 매치 바인딩은 Move의 다른 측면과 동일한 ability 제한 사항을 따릅니다.
특히, 와일드카드가 값을 삭제할 것으로 예상하므로 와일드카드를 사용하여 `drop` 없이 값(참조가 아닌)을 매치하려고 하면 컴파일러가 오류를 표시합니다. 유사하게, 바인더를 사용하여 non-`drop` 값을 바인딩하면 매치 암의 오른쪽에서 사용해야 합니다. 또한 해당 값을 완전히 해체하면 
[non-`drop` 구조체 언패킹](./../structs#destroying-structs-via-pattern-matching)의 의미와 일치하게 언패킹한 것입니다. `drop` 기능에 대한 자세한 내용은 [`drop`에 대한 abilities 섹션](./../abilities#drop)을 참조하세요.

```move
public struct NonDrop(u64)

fun drop_nondrop(x: NonDrop) {
    match (x) {
        NonDrop(1) => 1,
        _ => 2
        // 오류: 드롭할 수 없는 값에 와일드카드 매치를 사용할 수 없습니다
    }
}

fun destructure_nondrop(x: NonDrop) {
    match (x) {
        NonDrop(1) => 1,
        NonDrop(_) => 2
        // OK!
    }
}

fun use_nondrop(x: NonDrop): NonDrop {
    match (x) {
        NonDrop(1) => NonDrop(8),
        x => x
    }
}
```

## 완전성

Move의 `match` 표현식은 _완전_해야 합니다: 매치되는 타입의 모든 가능한 값이 매치의 암 중 하나의 패턴에 의해 포함되어야 합니다. 일련의 매치 암이 완전하지 않으면 컴파일러가 오류를 발생시킵니다. 가드 표현식이 있는 암은 런타임에 매치에 실패할 수 있으므로 매치 완전성에 기여하지 않습니다.

예를 들어, `u8`에 대한 매치는 와일드카드나 변수 패턴이 없는 한 0부터 255까지 _모든_ 숫자를 매치해야만 완전합니다. 유사하게, `bool`에 대한 매치는 와일드카드나 변수 패턴이 없는 한 `true`와 `false` 모두를 매치해야 합니다.

구조체의 경우, 타입에 대한 생성자가 하나뿐이므로 하나의 생성자만 매치하면 되지만, 구조체 내의 필드도 완전하게 매치되어야 합니다. 반대로, 열거형은 여러 변형을 정의할 수 있으며, 매치가 완전한 것으로 간주되려면 각 변형(하위 필드 포함)이 매치되어야 합니다.

밑줄과 변수는 해당 위치에서 매치하는 타입의 모든 값과 일치하는 와일드카드이므로 모든 값과 일치하는 것으로 계산됩니다. 또한 다중 항수 와일드카드 패턴 `..`를 사용하여 구조체나 열거형 변형 내의 여러 값을 매치할 수 있습니다.

_완전하지 않은_ 매치의 몇 가지 예를 보려면 다음을 고려하세요:

```move
public enum MyEnum {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

public struct Pair<T>(T, T)

fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) => 1,
        MyEnum::Variant(_, _) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        // 오류: `MyEnum::OtherVariant(_, 4)` 값이 매치되지 않으므로 완전하지 않습니다.
    }
}

fun match_pair_bool(x: Pair<bool>): u8 {
    match (x) {
        Pair(true, true) => 1,
        Pair(true, false) => 1,
        Pair(false, false) => 1,
        // 오류: `Pair(false, true)` 값이 매치되지 않으므로 완전하지 않습니다.
    }
}
```

이러한 예제는 매치 암의 끝에 와일드카드 패턴을 추가하거나 나머지 값을 완전히 매치하여 완전하게 만들 수 있습니다:

```move
fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) => 1,
        MyEnum::Variant(_, _) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        // 이제 MyEnum::OtherVariant의 모든 값과 일치하므로 완전합니다
        MyEnum::OtherVariant(..) => 2,

    }
}

fun match_pair_bool(x: Pair<bool>): u8 {
    match (x) {
        Pair(true, true) => 1,
        Pair(true, false) => 1,
        Pair(false, false) => 1,
        // 이제 Pair<bool>의 모든 값과 일치하므로 완전합니다
        Pair(false, true) => 1,
    }
}
```

## 가드

앞서 언급했듯이, 패턴 뒤에 `if` 절을 추가하여 매치 암에 가드를 추가할 수 있습니다. 이 가드는 패턴이 매치된 _후_ 그러나 화살표 오른쪽의 표현식이 평가되기 _전에_ 실행됩니다. 가드 표현식이 `true`로 평가되면 화살표 오른쪽의 표현식이 평가되고, `false`로 평가되면 매치 실패로 간주되어 `match` 표현식의 다음 매치 암이 검사됩니다.

```move
fun match_with_guard(x: u64): u64 {
    match (x) {
        1 if (false) => 1,
        1 => 2,
        _ => 3,
    }
}

match_with_guard(1); // 2를 반환
match_with_guard(0); // 3을 반환
```

가드 표현식은 평가 중에 패턴에 바인딩된 변수를 참조할 수 있습니다. 그러나 패턴에 가변성 지정자가 있거나 패턴이 값으로 매치되는 경우에도 _가드에서 변수는 불변 참조로만 사용 가능_하다는 점에 유의하세요.

```move
fun incr(x: &mut u64) {
    *x = *x + 1;
}

fun match_with_guard_incr(x: u64): u64 {
    match (x) {
        x if ({ incr(&mut x); x == 1 }) => 1,
        // 오류:    ^^^ 불변 값의 잘못된 차용
        _ => 2,
    }
}

fun match_with_guard_incr2(x: &mut u64): u64 {
    match (x) {
        x if ({ incr(&mut x); x == 1 }) => 1,
        // 오류:    ^^^ 불변 값의 잘못된 차용
        _ => 2,
    }
}
```

또한 컴파일러가 가드 표현식을 정적으로 평가할 방법이 없기 때문에 가드 표현식이 있는 매치 암은 완전성 목적으로 고려되지 않는다는 점에 유의하는 것이 중요합니다.

## 특정 패턴에 대한 제한 사항

패턴에서 `..`와 `mut` 패턴 수정자를 사용할 수 있는 시기에 대한 몇 가지 제한 사항이 있습니다.

### 가변성 사용

`mut` 수정자는 변수 패턴에 배치하여 _변수_가 매치 암의 오른쪽 표현식에서 변경될 것임을 지정할 수 있습니다. `mut` 수정자는 기본 데이터가 아닌 변수가 변경될 것임을 나타내므로 모든 유형의 매치(값별, 불변 참조, 가변 참조)에서 사용할 수 있습니다.

`mut` 수정자는 변수에만 적용할 수 있고 다른 유형의 패턴에는 적용할 수 없습니다.

```move
public struct MyStruct(u64)

fun top_level_mut(x: MyStruct) {
    match (x) {
        mut MyStruct(y) => 1,
        // 오류: 변수가 아닌 패턴에는 mut를 사용할 수 없습니다
    }
}

fun mut_on_immut(x: &MyStruct): u64 {
    match (x) {
        MyStruct(mut y) => {
            y = &(*y + 1);
            *y
        }
    }
}

fun mut_on_value(x: MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =>  {
            *y = *y + 1;
            *y
        },
    }
}

fun mut_on_mut(x: &mut MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =>  {
            *y = *y + 1;
            *y
        },
    }
}

let mut x = MyStruct(1);

mut_on_mut(&mut x); // 2를 반환
x.0; // 2를 반환

mut_on_immut(&x); // 3을 반환
x.0; // 2를 반환

mut_on_value(x); // 3을 반환
```

### `..` 사용

`..` 패턴은 생성자 패턴 내에서만 와일드카드로 사용할 수 있으며, 임의의 수의 필드와 일치합니다 -- 컴파일러는 `..`를 생성자 패턴에서 누락된 필드(있는 경우)에 `_`를 삽입하도록 확장합니다. 따라서 `MyStruct(_, _, _)`는 `MyStruct(..)`와 동일하고,
`MyStruct(1, _, _)`는 `MyStruct(1, ..)`와 동일합니다. 이 때문에 `..` 패턴을 사용할 수 있는 방법과 위치에 대한 몇 가지 제한 사항이 있습니다:

- 생성자 패턴 내에서 **한 번만** 사용할 수 있습니다;
- 위치 인자에서는 생성자 내 패턴의 시작, 중간 또는 끝에서 사용할 수 있습니다;
- 명명된 인자에서는 생성자 내 패턴의 끝에서만 사용할 수 있습니다;

```move
public struct MyStruct(u64, u64, u64, u64) has drop;

public struct MyStruct2 {
    x: u64,
    y: u64,
    z: u64,
    w: u64,
}

fun wild_match(x: MyStruct) {
    match (x) {
        MyStruct(.., 1) => 1,
        // OK! `..` 패턴은 생성자 패턴의 시작 부분에서 사용할 수 있습니다
        MyStruct(1, ..) => 2,
        // OK! `..` 패턴은 생성자 패턴의 끝에서 사용할 수 있습니다
        MyStruct(1, .., 1) => 3,
        // OK! `..` 패턴은 생성자 패턴의 중간에서 사용할 수 있습니다
        MyStruct(1, .., 1, 1) => 4,
        MyStruct(..) => 5,
    }
}

fun wild_match2(x: MyStruct2) {
    match (x) {
        MyStruct2 { x: 1, .. } => 1,
        MyStruct2 { x: 1, w: 2 .. } => 2,
        MyStruct2 { .. } => 3,
    }
}
```