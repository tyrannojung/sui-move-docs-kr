---
title: 'Vector | Reference'
description: ''
---

# Vector

`vector<T>`는 Move에서 제공하는 유일한 원시 컬렉션 타입입니다. `vector<T>`는 "끝"에서 값을 추가(push)하거나 제거(pop)하여 크기가 늘어나거나 줄어들 수 있는 `T`의 동질적인(homogeneous) 컬렉션입니다.

`vector<T>`는 모든 타입 `T`로 인스턴스화할 수 있습니다. 예를 들어, `vector<u64>`, `vector<address>`,
`vector<0x42::my_module::MyData>`, `vector<vector<u8>>` 모두 유효한 벡터 타입입니다.

## 리터럴

### 일반 `vector` 리터럴

모든 타입의 벡터는 `vector` 리터럴로 생성할 수 있습니다.

| 구문                  | 타입                                                                          | 설명                                       |
| --------------------- | ----------------------------------------------------------------------------- | ------------------------------------------ |
| `vector[]`            | `vector[]: vector<T>` where `T` is any single, non-reference type             | 빈 벡터                                    |
| `vector[e1, ..., en]` | `vector[e1, ..., en]: vector<T>` where `e_i: T` s.t. `0 < i <= n` and `n > 0` | `n`개의 요소를 가진 벡터 (길이 `n`)        |

이러한 경우 `vector`의 타입은 요소 타입이나 벡터의 사용법으로부터 추론됩니다. 타입을 추론할 수 없거나 단순히 명확성을 위해 타입을 명시적으로 지정할 수 있습니다:

```move
vector<T>[]: vector<T>
vector<T>[e1, ..., en]: vector<T>
```

#### 벡터 리터럴 예제

```move
(vector[]: vector<bool>);
(vector[0u8, 1u8, 2u8]: vector<u8>);
(vector<u128>[]: vector<u128>);
(vector<address>[@0x42, @0x100]: vector<address>);
```

### `vector<u8>` 리터럴

Move에서 벡터의 일반적인 사용 사례는 `vector<u8>`로 표현되는 "바이트 배열"을 나타내는 것입니다. 이러한 값들은 공개 키나 해시 결과와 같은 암호화 목적으로 자주 사용됩니다. 이러한 값들이 매우 일반적이므로 각 개별 `u8` 값을 숫자 형식으로 지정해야 하는 `vector[]`를 사용하는 대신, 값을 더 읽기 쉽게 만드는 특별한 구문이 제공됩니다.

현재 `vector<u8>` 리터럴은 _바이트 문자열(byte strings)_ 과 _16진수 문자열(hex strings)_ 두 가지 타입이 지원됩니다.

#### 바이트 문자열

바이트 문자열은 `b` 접두사가 붙은 따옴표로 묶인 문자열 리터럴입니다. 예: `b"Hello!\n"`.

이들은 이스케이프 시퀀스를 허용하는 ASCII 인코딩된 문자열입니다. 현재 지원되는 이스케이프 시퀀스는 다음과 같습니다:

| 이스케이프 시퀀스 | 설명                                           |
| ----------------- | ---------------------------------------------- |
| `\n`              | 개행 (또는 줄 바꿈)                            |
| `\r`              | 캐리지 리턴                                    |
| `\t`              | 탭                                             |
| `\\`              | 백슬래시                                       |
| `\0`              | 널(Null)                                       |
| `\"`              | 따옴표                                         |
| `\xHH`            | 16진수 이스케이프, 16진수 바이트 시퀀스 `HH` 삽입 |

#### 16진수 문자열

16진수 문자열은 `x` 접두사가 붙은 따옴표로 묶인 문자열 리터럴입니다. 예: `x"48656C6C6F210A"`.

`00`부터 `FF`까지의 각 바이트 쌍은 16진수로 인코딩된 `u8` 값으로 해석됩니다. 따라서 각 바이트 쌍은 결과 `vector<u8>`의 단일 항목에 해당합니다.

#### 문자열 리터럴 예제

```move
fun byte_and_hex_strings() {
    assert!(b"" == x"", 0);
    assert!(b"Hello!\n" == x"48656C6C6F210A", 1);
    assert!(b"\x48\x65\x6C\x6C\x6F\x21\x0A" == x"48656C6C6F210A", 2);
    assert!(
        b"\"Hello\tworld!\"\n \r \\Null=\0" ==
            x"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00",
        3
    );
}
```

## 연산

`vector`는 Move 표준 라이브러리의 `std::vector` 모듈을 통해 다음 연산을 지원합니다:

| 함수                                                       | 설명                                                                                                                                                            | 중단 조건                      |
| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| `vector::empty<T>(): vector<T>`                            | 타입 `T`의 값을 저장할 수 있는 빈 벡터 생성                                                                                                                     | 없음                           |
| `vector::singleton<T>(t: T): vector<T>`                    | `t`를 포함하는 크기 1의 벡터 생성                                                                                                                               | 없음                           |
| `vector::push_back<T>(v: &mut vector<T>, t: T)`            | `v`의 끝에 `t` 추가                                                                                                                                             | 없음                           |
| `vector::pop_back<T>(v: &mut vector<T>): T`                | `v`의 마지막 요소를 제거하고 반환                                                                                                                               | `v`가 비어있을 때              |
| `vector::borrow<T>(v: &vector<T>, i: u64): &T`             | 인덱스 `i`에 있는 `T`에 대한 불변 참조 반환                                                                                                                     | `i`가 범위를 벗어날 때         |
| `vector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T` | 인덱스 `i`에 있는 `T`에 대한 가변 참조 반환                                                                                                                     | `i`가 범위를 벗어날 때         |
| `vector::destroy_empty<T>(v: vector<T>)`                   | `v` 삭제                                                                                                                                                        | `v`가 비어있지 않을 때         |
| `vector::append<T>(v1: &mut vector<T>, v2: vector<T>)`     | `v2`의 요소들을 `v1`의 끝에 추가                                                                                                                                | 없음                           |
| `vector::contains<T>(v: &vector<T>, e: &T): bool`          | `e`가 벡터 `v`에 있으면 true 반환. 그렇지 않으면 false 반환                                                                                                     | 없음                           |
| `vector::swap<T>(v: &mut vector<T>, i: u64, j: u64)`       | 벡터 `v`에서 `i`번째와 `j`번째 인덱스의 요소를 교환                                                                                                             | `i` 또는 `j`가 범위를 벗어날 때 |
| `vector::reverse<T>(v: &mut vector<T>)`                    | 벡터 `v`의 요소 순서를 제자리에서 역순으로 변경                                                                                                                 | 없음                           |
| `vector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)`   | `e`가 벡터 `v`의 인덱스 `i`에 있으면 `(true, i)` 반환. 그렇지 않으면 `(false, 0)` 반환                                                                          | 없음                           |
| `vector::remove<T>(v: &mut vector<T>, i: u64): T`          | 벡터 `v`의 `i`번째 요소를 제거하고, 이후의 모든 요소를 이동. 이는 O(n)이며 벡터의 요소 순서를 유지                                                               | `i`가 범위를 벗어날 때         |
| `vector::swap_remove<T>(v: &mut vector<T>, i: u64): T`     | 벡터 `v`의 `i`번째 요소를 마지막 요소와 교환한 다음 해당 요소를 제거. 이는 O(1)이지만 벡터의 요소 순서를 유지하지 않음                                           | `i`가 범위를 벗어날 때         |

{/* TODO we should just link out to generated stdlib docs? Maybe?  */}

시간이 지나면서 더 많은 연산이 추가될 수 있습니다.

## 예제

```move
use std::vector;

let mut v = vector::empty<u64>();
vector::push_back(&mut v, 5);
vector::push_back(&mut v, 6);

assert!(*vector::borrow(&v, 0) == 5, 42);
assert!(*vector::borrow(&v, 1) == 6, 42);
assert!(vector::pop_back(&mut v) == 6, 42);
assert!(vector::pop_back(&mut v) == 5, 42);
```

## `vector` 소멸과 복사

`vector<T>`의 일부 동작은 요소 타입 `T`의 능력(abilities)에 따라 달라집니다. 예를 들어, `drop`을 가지지 않은 요소를 포함하는 벡터는 위의 예제에서 `v`처럼 암시적으로 폐기될 수 없습니다--반드시 `vector::destroy_empty`로 명시적으로 소멸시켜야 합니다.

`vector::destroy_empty`는 `vec`이 0개의 요소를 포함하지 않는 한 런타임에 중단된다는 점에 유의하세요:

```move
fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
```

하지만 `drop`을 가진 요소를 포함하는 벡터를 폐기할 때는 오류가 발생하지 않습니다:

```move
fun destroy_droppable_vector<T: drop>(vec: vector<T>) {
    // valid!
    // nothing needs to be done explicitly to destroy the vector
}
```

마찬가지로, 요소 타입이 `copy`를 가지지 않는 한 벡터는 복사될 수 없습니다. 다시 말해, `vector<T>`는 `T`가 `copy`를 가진 경우에만 `copy`를 가집니다. 필요한 경우 암시적으로 복사된다는 점에 유의하세요:

```move
let x = vector[10];
let y = x; // implicit copy
let z = x;
(y, z)
```

큰 벡터의 복사는 비용이 많이 들 수 있다는 점을 명심하세요. 이것이 우려되는 경우, `의도된` 사용법을 주석으로 표시하면 실수로 복사하는 것을 방지할 수 있습니다. 예를 들어:

```move
let x = vector[10];
let y = move x;
let z = x; // ERROR! x has been moved
(y, z)
```

더 자세한 내용은 [타입 능력](./../abilities)과 [제네릭](./../generics) 섹션을 참조하세요.

## 소유권

[위에서](#destroying-and-copying-vectors) 언급했듯이, `vector` 값은 요소가 복사 가능한 경우에만 복사될 수 있습니다. 이 경우, 복사는 [`copy`](./../variables#move-and-copy) 또는 [역참조 `*`](./references#reading-and-writing-through-references)를 통해 수행될 수 있습니다.
