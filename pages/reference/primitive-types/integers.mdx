---
title: '정수 | Reference'
description: ''
---

# 정수

Move는 6개의 부호 없는 정수 타입을 지원합니다: `u8`, `u16`, `u32`, `u64`, `u128`, 그리고 `u256`. 이러한 타입의 값은 0부터 타입 크기에 따라 달라지는 최댓값까지의 범위를 가집니다.

| 타입                             | 값 범위                  |
| -------------------------------- | ------------------------ |
| 부호 없는 8비트 정수, `u8`       | 0 to 2<sup>8</sup> - 1   |
| 부호 없는 16비트 정수, `u16`     | 0 to 2<sup>16</sup> - 1  |
| 부호 없는 32비트 정수, `u32`     | 0 to 2<sup>32</sup> - 1  |
| 부호 없는 64비트 정수, `u64`     | 0 to 2<sup>64</sup> - 1  |
| 부호 없는 128비트 정수, `u128`   | 0 to 2<sup>128</sup> - 1 |
| 부호 없는 256비트 정수, `u256`   | 0 to 2<sup>256</sup> - 1 |

## 리터럴

이러한 타입의 리터럴 값은 숫자 시퀀스(예: `112`) 또는 16진수 리터럴(예: `0xFF`)로 지정됩니다. 리터럴의 타입은 선택적으로 접미사로 추가할 수 있습니다(예: `112u8`).
타입이 지정되지 않으면, 컴파일러는 리터럴이 사용되는 컨텍스트에서 타입을 추론하려고 시도합니다. 타입을 추론할 수 없는 경우, `u64`로 간주됩니다.

숫자 리터럴은 그룹화와 가독성을 위해 밑줄로 구분할 수 있습니다. (예: `1_234_5678`,
`1_000u128`, `0xAB_CD_12_35`).

리터럴이 지정된(또는 추론된) 크기 범위에 비해 너무 큰 경우, 오류가 보고됩니다.

### 예제

```move
// literals with explicit annotations;
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// literals with simple inference
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// literals with more complex inference
let complex_u8 = 1; // inferred: u8
// right hand argument to shift must be u8
let _unused = 10 << complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // inferred: u8
// arguments to `+` must have the same type
let _unused = x + complex_u8;

let complex_u128 = 133_876; // inferred: u128
// inferred from function argument type
function_that_takes_u128(complex_u128);

// literals can be written in hex
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
```

## 연산

### 산술 연산

각 타입은 동일한 검사된 산술 연산 세트를 지원합니다. 이러한 모든 연산에서 두 인자(왼쪽과 오른쪽 피연산자)는 _반드시_ 동일한 타입이어야 합니다. 다른 타입의 값에 대해 연산을 수행해야 하는 경우, 먼저 [캐스트](#casting)를 수행해야 합니다.
마찬가지로, 연산 결과가 정수 타입에 비해 너무 클 것으로 예상되는 경우, 연산을 수행하기 전에 더 큰 크기로 [캐스트](#casting)를 수행하세요.

모든 산술 연산은 수학적 정수가 하지 않을 방식으로 동작하는 대신 중단됩니다(예: 오버플로우(overflow), 언더플로우(underflow), 0으로 나누기).

| 구문   | 연산             | 중단 조건                                |
| ------ | ---------------- | ---------------------------------------- |
| `+`    | 덧셈             | 결과가 정수 타입에 비해 너무 큼         |
| `-`    | 뺄셈             | 결과가 0보다 작음                        |
| `*`    | 곱셈             | 결과가 정수 타입에 비해 너무 큼         |
| `%`    | 나머지 연산      | 제수가 `0`인 경우                        |
| `/`    | 절단 나눗셈      | 제수가 `0`인 경우                        |

### 비트 연산

정수 타입은 각 숫자를 수치적 정수 값 대신 개별 비트(0 또는 1)의 시리즈로 처리하는 다음 비트 연산을 지원합니다.

비트 연산은 중단되지 않습니다.

| 구문                | 연산        | 설명                                                  |
| ------------------- | ----------- | ----------------------------------------------------- |
| `&`                 | 비트 AND    | 각 비트 쌍에 대해 불리언 AND를 수행합니다            |
| <code>&#124;</code> | 비트 OR     | 각 비트 쌍에 대해 불리언 OR를 수행합니다             |
| `^`                 | 비트 XOR    | 각 비트 쌍에 대해 불리언 배타적 OR를 수행합니다      |

### 비트 시프트

비트 연산과 마찬가지로, 각 정수 타입은 비트 시프트를 지원합니다. 하지만 다른 연산과 달리, 오른쪽 피연산자(시프트할 비트 수)는 _항상_ `u8`이어야 하며 왼쪽 피연산자(시프트할 숫자)와 일치할 필요는 없습니다.

비트 시프트는 시프트할 비트 수가 `u8`, `u16`, `u32`, `u64`, `u128`, `u256`에 대해 각각 `8`, `16`, `32`,
`64`, `128` 또는 `256`보다 크거나 같은 경우 중단될 수 있습니다.

| 구문   | 연산        | 중단 조건                                                            |
| ------ | ----------- | -------------------------------------------------------------------- |
| `<<`   | 왼쪽 시프트 | 시프트할 비트 수가 정수 타입의 크기보다 큰 경우                     |
| `>>`   | 오른쪽 시프트 | 시프트할 비트 수가 정수 타입의 크기보다 큰 경우                   |

### 비교

정수 타입은 Move에서 비교 연산자를 사용할 수 있는 _유일한_ 타입입니다. 두 인자는 동일한 타입이어야 합니다. 다른 타입의 정수를 비교해야 하는 경우, 먼저 둘 중 하나를 [캐스트](#casting)해야 합니다.

비교 연산은 중단되지 않습니다.

| 구문   | 연산             |
| ------ | ---------------- |
| `<`    | 미만             |
| `>`    | 초과             |
| `<=`   | 이하             |
| `>=`   | 이상             |

### 동등성

[`drop`](./../abilities)을 가진 모든 타입과 마찬가지로, 모든 정수 타입은 ["같음"](./../equality)과 ["같지 않음"](./../equality) 연산을 지원합니다. 두 인자는 동일한 타입이어야 합니다. 다른 타입의 정수를 비교해야 하는 경우, 먼저 둘 중 하나를 [캐스트](#casting)해야 합니다.

동등성 연산은 중단되지 않습니다.

| 구문   | 연산      |
| ------ | --------- |
| `==`   | 같음      |
| `!=`   | 같지 않음 |

더 자세한 내용은 [동등성](./../equality) 섹션을 참조하세요.

## 캐스팅

한 크기의 정수 타입은 다른 크기의 정수 타입으로 캐스트(cast)할 수 있습니다. 정수는 Move에서 캐스팅을 지원하는 유일한 타입입니다.

캐스트는 절단하지 _않습니다_. 결과가 지정된 타입에 비해 너무 큰 경우 캐스팅이 중단됩니다.

| 구문       | 연산                                                 | 중단 조건                              |
| ---------- | ---------------------------------------------------- | -------------------------------------- |
| `(e as T)` | 정수 표현식 `e`를 정수 타입 `T`로 캐스트            | `e`가 `T`로 표현하기에 너무 큰 경우   |

여기서 `e`의 타입은 `8`, `16`, `32`, `64`, `128` 또는 `256`이어야 하고 `T`는 `u8`, `u16`,
`u32`, `u64`, `u128`, 또는 `u256`이어야 합니다.

예를 들어:

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

## 소유권

언어에 내장된 다른 스칼라 값과 마찬가지로, 정수 값은 암시적으로 복사 가능합니다.
즉, [`copy`](./../variables#move-and-copy)와 같은 명시적인 명령 없이도 복사할 수 있습니다.