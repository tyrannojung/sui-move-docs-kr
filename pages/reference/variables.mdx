---
title: '지역 변수와 스코프 | Reference'
description: ''
---

# 지역 변수와 스코프

Move의 지역 변수는 어휘적(정적) 스코프를 가집니다. 새로운 변수는 `let` 키워드로 도입되며, 같은 이름을 가진 이전 지역 변수를 가리게(shadow) 됩니다. `mut`로 표시된 지역 변수는 가변이며 직접 또는 가변 참조를 통해 업데이트할 수 있습니다.

## 지역 변수 선언하기

### `let` 바인딩

Move 프로그램은 `let`을 사용하여 변수 이름을 값에 바인딩합니다:

```move
let x = 1;
let y = x + x:
```

`let`은 지역 변수에 값을 바인딩하지 않고도 사용할 수 있습니다.

```move
let x;
```

그러면 나중에 지역 변수에 값을 할당할 수 있습니다.

```move
let x;
if (cond) {
  x = 1
} else {
  x = 0
}
```

이는 기본값을 제공할 수 없을 때 루프에서 값을 추출하려고 할 때 매우 유용할 수 있습니다.

```move
let x;
let cond = true;
let i = 0;
loop {
    let (res, cond) = foo(i);
    if (!cond) {
        x = res;
        break;
    };
    i = i + 1;
}
```

지역 변수가 할당된 _후_ 수정하거나 가변으로 빌리려면 `&mut`, `mut`로 선언해야 합니다.

```move
let mut x = 0;
if (cond) x = x + 1;
foo(&mut x);
```

자세한 내용은 아래 [할당](#assignments) 섹션을 참조하세요.

### 변수는 사용하기 전에 할당되어야 합니다

Move의 타입 시스템은 지역 변수가 할당되기 전에 사용되는 것을 방지합니다.

```move
let x;
// highlight-error
x + x // ERROR! x가 할당되기 전에 사용됨
```

```move
let x;
if (cond) x = 0;
// highlight-error
x + x // ERROR! x가 모든 경우에 값을 가지지 않음
```

```move
let x;
while (cond) x = 0;
// highlight-error
x + x // ERROR! x가 모든 경우에 값을 가지지 않음
```

### 유효한 변수 이름

변수 이름은 밑줄 `_`, 문자 `a`부터 `z`, 문자 `A`부터 `Z`, 숫자 `0`부터 `9`를 포함할 수 있습니다. 변수 이름은 밑줄 `_` 또는 문자 `a`부터 `z`로 시작해야 합니다. 대문자로 시작할 수 _없습니다_.

```move
// 모두 유효함
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// 모두 유효하지 않음
// highlight-error-start
let X = e; // ERROR!
let Foo = e; // ERROR!
// highlight-error-end
```

### 타입 주석

지역 변수의 타입은 거의 항상 Move의 타입 시스템에 의해 추론될 수 있습니다. 그러나 Move는 가독성, 명확성 또는 디버깅을 위해 유용할 수 있는 명시적 타입 주석을 허용합니다. 타입 주석을 추가하는 구문은 다음과 같습니다:

```move
let x: T = e; // "타입 T의 변수 x가 표현식 e로 초기화됨"
```

명시적 타입 주석의 몇 가지 예:

```move
module 0::example;

public struct S { f: u64, g: u64 }

fun annotated() {
    let u: u8 = 0;
    let b: vector<u8> = b"hello";
    let a: address = @0x0;
    let (x, y): (&u64, &mut u64) = (&0, &mut 1);
    let S { f, g: f2 }: S = S { f: 0, g: 1 };
}
```

타입 주석은 항상 패턴의 오른쪽에 있어야 한다는 점에 유의하세요:

```move
// highlight-error-start
// ERROR! let (x, y): (&u64, &mut u64) = ... 이어야 함
let (x: &u64, y: &mut u64) = (&0, &mut 1);
// highlight-error-end
```

### 주석이 필요한 경우

경우에 따라 타입 시스템이 타입을 추론할 수 없는 경우 지역 타입 주석이 필요합니다. 이는 일반적으로 제네릭 타입의 타입 인자를 추론할 수 없을 때 발생합니다. 예를 들어:

```move
// highlight-error-start
let _v1 = vector[]; // ERROR!
//        ^^^^^^^^ 이 타입을 추론할 수 없습니다. 주석을 추가해 보세요
// highlight-error-end
let v2: vector<u64> = vector[]; // 에러 없음
```

더 드문 경우로, 타입 시스템이 발산하는 코드(divergent code, 다음 코드가 모두 도달할 수 없는 경우)에 대한 타입을 추론하지 못할 수 있습니다. [`return`](./functions#return-expression)과 [`abort`](./abort-and-assert)는 모두 표현식이며 어떤 타입이든 가질 수 있습니다. [`loop`](./control-flow/loops)는 `break`가 있으면 타입 `()`를 가지며 (`e: T`인 `break e`가 있으면 `T`), 루프에서 빠져나오는 break가 없으면 어떤 타입이든 가질 수 있습니다. 이러한 타입을 추론할 수 없는 경우 타입 주석이 필요합니다. 예를 들어, 이 코드:

```move
let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

// highlight-error-start
let x = return (); // ERROR!
//  ^ 이 타입을 추론할 수 없습니다. 주석을 추가해 보세요
let y = abort 0; // ERROR!
//  ^ 이 타입을 추론할 수 없습니다. 주석을 추가해 보세요
let z = loop (); // ERROR!
//  ^ 이 타입을 추론할 수 없습니다. 주석을 추가해 보세요
// highlight-error-end
```

이 코드에 타입 주석을 추가하면 죽은 코드나 사용되지 않은 지역 변수에 대한 다른 오류가 노출되지만, 이 예제는 여전히 이 문제를 이해하는 데 도움이 됩니다.

### 튜플을 사용한 다중 선언

`let`은 튜플을 사용하여 한 번에 둘 이상의 지역 변수를 도입할 수 있습니다. 괄호 안에 선언된 지역 변수는 튜플의 해당 값으로 초기화됩니다.

```move
let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
```

표현식의 타입은 튜플 패턴의 개수와 정확히 일치해야 합니다.

```move
// highlight-error
let (x, y) = (0, 1, 2); // ERROR!
// highlight-error
let (x, y, z, q) = (0, 1, 2); // ERROR!
```

단일 `let`에서 같은 이름을 가진 지역 변수를 둘 이상 선언할 수 없습니다.

```move
// highlight-error
let (x, x) = 0; // ERROR!
```

선언된 지역 변수의 가변성은 혼합될 수 있습니다.

```move
let (mut x, y) = (0, 1);
x = 1;
```

### 구조체를 사용한 다중 선언

`let`은 구조체를 구조 분해(또는 매칭)할 때도 한 번에 둘 이상의 지역 변수를 도입할 수 있습니다. 이 형태에서 `let`은 구조체의 필드 값으로 초기화되는 지역 변수 집합을 생성합니다. 구문은 다음과 같습니다:

```move
public struct T { f1: u64, f2: u64 }
```

```move
let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
```

위치 구조체(positional structs)도 마찬가지입니다

```move
public struct P(u64, u64)
```

그리고

```move
let P (local1, local2) = P ( 1, 2 );
// local1: u64
// local2: u64
```

다음은 더 복잡한 예입니다:

```move
module 0::example;

public struct X(u64)
public struct Y { x1: X, x2: X }

fun new_x(): X {
    X(1)
}

fun example() {
    let Y { x1: X(f), x2 } = Y { x1: new_x(), x2: new_x() };
    assert!(f + x2.f == 2, 42);

    let Y { x1: X(f1), x2: X(f2) } = Y { x1: new_x(), x2: new_x() };
    assert!(f1 + f2 == 2, 42);
}
```

구조체의 필드는 바인딩할 필드를 식별하는 것과 _동시에_ 변수의 이름을 지정하는 이중 역할을 할 수 있습니다. 이를 때때로 펀닝(punning)이라고 합니다.

```move
let Y { x1, x2 } = e;
```

다음과 동일합니다:

```move
let Y { x1: x1, x2: x2 } = e;
```

튜플에서 보았듯이, 단일 `let`에서 같은 이름을 가진 지역 변수를 둘 이상 선언할 수 없습니다.

```move
// highlight-error
let Y { x1: x, x2: x } = e; // ERROR!
```

그리고 튜플과 마찬가지로, 선언된 지역 변수의 가변성은 혼합될 수 있습니다.

```move
let Y { x1: mut x1, x2 } = e;
```

또한, 가변성 주석은 펀닝된 필드에 적용될 수 있습니다. 다음과 동일한 예를 제공합니다

```move
let Y { mut x1, x2 } = e;
```

### 참조에 대한 구조 분해

위의 구조체 예제에서 let의 바인딩된 값은 이동(move)되어 구조체 값을 파괴하고 필드를 바인딩했습니다.

```move
public struct T { f1: u64, f2: u64 }
```

```move
let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
```

이 시나리오에서 구조체 값 `T { f1: 1, f2: 2 }`는 `let` 이후에 더 이상 존재하지 않습니다.

구조체 값을 이동하여 파괴하지 않으려면 대신 각 필드를 빌릴 수 있습니다. 예를 들어:

```move
let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &t;
// local1: &u64
// local2: &u64
```

가변 참조도 마찬가지입니다:

```move
let mut t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &mut t;
// local1: &mut u64
// local2: &mut u64
```

이 동작은 중첩된 구조체에서도 작동할 수 있습니다.

```move
module 0::example;

public struct X(u64)
public struct Y { x1: X, x2: X }

fun new_x(): X {
    X(1)
}

fun example() {
    let mut y = Y { x1: new_x(), x2: new_x() };

    let Y { x1: X(f), x2 } = &y;
    assert!(*f + x2.f == 2, 42);

    let Y { x1: X(f1), x2: X(f2) } = &mut y;
    *f1 = *f1 + 1;
    *f2 = *f2 + 1;
    assert!(*f1 + *f2 == 4, 42);
}
```

### 값 무시하기

`let` 바인딩에서 일부 값을 무시하는 것이 종종 도움이 됩니다. `_`로 시작하는 지역 변수는 무시되고 새 변수를 도입하지 않습니다

```move
fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
```

```move
let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2, 42);
```

컴파일러가 사용되지 않은 지역 변수에 대해 경고하므로 때때로 이것이 필요할 수 있습니다

```move
let (x1, y, z1) = three(); // WARNING!
//       ^ 사용되지 않은 지역 변수 'y'
```

### 일반적인 `let` 문법

`let`의 모든 다른 구조를 결합할 수 있습니다! 이로써 우리는 `let` 문에 대한 다음과 같은 일반 문법에 도달합니다:

> _let-binding_ → **let** _pattern-or-list_ _type-annotation_<sub>_opt_</sub> >
> _initializer_<sub>_opt_</sub> > _pattern-or-list_ → _pattern_ | **(** _pattern-list_ **)** >
> _pattern-list_ → _pattern_ **,**<sub>_opt_</sub> | _pattern_ **,** _pattern-list_ >
> _type-annotation_ → **:** _type_ _initializer_ → **=** _expression_

바인딩을 도입하는 항목의 일반적인 용어는 _패턴(pattern)_ 입니다. 패턴은 데이터를 구조 분해하고(재귀적으로 가능) 바인딩을 도입하는 역할을 합니다. 패턴 문법은 다음과 같습니다:

> _pattern_ -> _local-variable_ | _struct-type_ **\{** _field-binding-list_ **\}** >
> _field-binding-list_ → _field-binding_ **,**<sub>_opt_</sub> | _field-binding_ **,** >
> _field-binding-list_ > _field-binding_ → _field_ | _field_ **:** _pattern_

이 문법이 적용된 몇 가지 구체적인 예:

```move
    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable
//       ^                           pattern
//          ^                        local-variable
//          ^                        pattern
//          ^                        pattern-list
//       ^^^^                        pattern-list
//      ^^^^^^                       pattern-or-list
//            ^^^^^^^^^^^^           type-annotation
//                         ^^^^^^^^  initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type
//            ^                                field
//            ^                                field-binding
//               ^                             field
//                  ^                          local-variable
//                  ^                          pattern
//               ^^^^                          field-binding
//            ^^^^^^^                          field-binding-list
//      ^^^^^^^^^^^^^^^                        pattern
//      ^^^^^^^^^^^^^^^                        pattern-or-list
//                      ^^^^^^^^^^^^^^^^^^^^   initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding
```

## 변형(Mutations)

### 할당

지역 변수가 도입된 후(`let` 또는 함수 매개변수로), `mut` 지역 변수는 할당을 통해 수정할 수 있습니다:

```move
x = e
```

`let` 바인딩과 달리 할당은 표현식입니다. 일부 언어에서는 할당이 할당된 값을 반환하지만, Move에서는 모든 할당의 타입이 항상 `()`입니다.

```move
(x = e: ())
```

실제로 할당이 표현식이라는 것은 중괄호(`{`...`}`)로 새 표현식 블록을 추가하지 않고도 사용할 수 있다는 의미입니다.

```move
let x;
if (cond) x = 1 else x = 2;
```

할당은 `let` 바인딩과 유사한 패턴 구문 체계를 사용하지만 `mut`가 없습니다:

```move
module 0::example;

public struct X { f: u64 }

fun new_x(): X {
    X { f: 1 }
}

// 참고: 이 예제는 사용되지 않은 변수와 할당에 대해 불평할 것입니다.
fun example() {
    let (mut x, mut y, mut f, mut g) = (0, 0, 0, 0);

    (X { f }, X { f: x }) = (new_x(), new_x());
    assert!(f + x == 2, 42);

    (x, y, f, _, g) = (0, 0, 0, 0, 0);
}
```

지역 변수는 하나의 타입만 가질 수 있으므로 할당 간에 지역 변수의 타입은 변경될 수 없습니다.

```move
let mut x;
x = 0;
// highlight-error
x = false; // ERROR!
```

### 참조를 통한 변형

할당으로 지역 변수를 직접 수정하는 것 외에도, `mut` 지역 변수는 가변 참조 `&mut`를 통해 수정할 수 있습니다.

```move
let mut x = 0;
let r = &mut x;
*r = 1;
assert!(x == 1, 42);
```

이는 다음과 같은 경우에 특히 유용합니다:

(1) 어떤 조건에 따라 다른 변수를 수정하려는 경우.

```move
let mut x = 0;
let mut y = 1;
let r = if (cond) &mut x else &mut y;
*r = *r + 1;
```

(2) 다른 함수가 지역 값을 수정하도록 하려는 경우.

```move
let mut x = 0;
modify_ref(&mut x);
```

이런 종류의 수정은 구조체와 벡터를 수정하는 방법입니다!

```move
let mut v = vector[];
vector::push_back(&mut v, 100);
assert!(*vector::borrow(&v, 0) == 100, 42);
```

자세한 내용은 [Move 참조](./primitive-types/references)를 참조하세요.

## 스코프

`let`으로 선언된 모든 지역 변수는 _해당 스코프 내에서_ 후속 표현식에 사용할 수 있습니다.
스코프는 표현식 블록인 `{`...`}`로 선언됩니다.

지역 변수는 선언된 스코프 밖에서 사용할 수 없습니다.

```move
let x = 0;
{
    let y = 1;
};
// highlight-error-start
x + y // ERROR!
//  ^ 바인딩되지 않은 지역 변수 'y'
// highlight-error-end
```

그러나 외부 스코프의 지역 변수는 중첩된 스코프에서 사용할 수 있습니다.

```move
{
    let x = 0;
    {
        let y = x + 1; // 유효함
    }
}
```

지역 변수는 접근 가능한 모든 스코프에서 변형될 수 있습니다. 해당 변형은 변형을 수행한 스코프에 관계없이 지역 변수와 함께 유지됩니다.

```move
let mut x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
```

### 표현식 블록

표현식 블록은 세미콜론(`;`)으로 구분된 일련의 문장입니다. 표현식 블록의 결과 값은 블록의 마지막 표현식의 값입니다.

```move
{ let x = 1; let y = 1; x + y }
```

이 예제에서 블록의 결과는 `x + y`입니다.

문장은 `let` 선언이거나 표현식일 수 있습니다. 할당(`x = e`)은 타입 `()`의 표현식임을 기억하세요.

```move
{ let x; let y = 1; x = 1; x + y }
```

함수 호출은 타입 `()`의 또 다른 일반적인 표현식입니다. 데이터를 수정하는 함수 호출은 일반적으로 문장으로 사용됩니다.

```move
{ let v = vector[]; vector::push_back(&mut v, 1); v }
```

이는 `()` 타입에만 국한되지 않습니다. 모든 표현식이 시퀀스에서 문장으로 사용될 수 있습니다!

```move
{
    let x = 0;
    x + 1; // 값이 버려짐
    x + 2; // 값이 버려짐
    b"hello"; // 값이 버려짐
}
```

하지만! 표현식이 리소스(`drop` [ability](./abilities)가 없는 값)를 포함하는 경우 오류가 발생합니다. 이는 Move의 타입 시스템이 삭제되는 모든 값이 `drop` [ability](./abilities)를 가지도록 보장하기 때문입니다. (소유권은 이전되거나 값이 선언 module 내에서 명시적으로 파괴되어야 합니다.)

```move
{
    let x = 0;
// highlight-error-start
    Coin { value: x }; // ERROR!
//  ^^^^^^^^^^^^^^^^^ `drop` ability가 없는 사용되지 않은 값
// highlight-error-end
    x
}
```

블록에 최종 표현식이 없는 경우, 즉 후행 세미콜론 `;`가 있는 경우, 암시적인 [단위 `()` 값](https://en.wikipedia.org/wiki/Unit_type)이 있습니다. 마찬가지로 표현식 블록이 비어 있으면 암시적인 단위 `()` 값이 있습니다.

둘 다 동일합니다

```move
{ x = x + 1; 1 / x; }
```

```move
{ x = x + 1; 1 / x; () }
```

마찬가지로 둘 다 동일합니다

```move
{ }
```

```move
{ () }
```

표현식 블록은 그 자체로 표현식이며 표현식이 사용되는 모든 곳에서 사용할 수 있습니다. (참고: 함수의 본문도 표현식 블록이지만 함수 본문은 다른 표현식으로 대체될 수 없습니다.)

```move
let my_vector: vector<vector<u8>> = {
    let mut v = vector[];
    vector::push_back(&mut v, b"hello");
    vector::push_back(&mut v, b"goodbye");
    v
};
```

(이 예제에서는 타입 주석이 필요하지 않으며 명확성을 위해서만 추가되었습니다.)

### 섀도잉(Shadowing)

`let`이 이미 스코프에 있는 이름을 가진 지역 변수를 도입하면, 해당 이전 변수는 이 스코프의 나머지 부분에서 더 이상 액세스할 수 없습니다. 이를 _섀도잉_ 이라고 합니다.

```move
let x = 0;
assert!(x == 0, 42);

let x = 1; // x가 섀도잉됨
assert!(x == 1, 42);
```

지역 변수가 섀도잉되면 이전과 동일한 타입을 유지할 필요가 없습니다.

```move
let x = 0;
assert!(x == 0, 42);

let x = b"hello"; // x가 섀도잉됨
assert!(x == b"hello", 42);
```

지역 변수가 섀도잉된 후에도 지역 변수에 저장된 값은 여전히 존재하지만 더 이상 액세스할 수 없습니다. 이는 [`drop` ability](./abilities)가 없는 타입의 값을 염두에 두는 것이 중요합니다. 값의 소유권은 함수가 끝날 때까지 이전되어야 하기 때문입니다.

```move
module 0::example;

public struct Coin has store { value: u64 }

fun unused_coin(): Coin {
// highlight-error-start
    let x = Coin { value: 0 }; // ERROR!
//      ^ 이 지역 변수는 여전히 `drop` ability가 없는 값을 포함합니다
    x.value = 1;
    let x = Coin { value: 10 };
    x
//  ^ 잘못된 반환
// highlight-error-end
}
```

지역 변수가 스코프 내에서 섀도잉되면, 섀도잉은 해당 스코프에만 남아 있습니다. 해당 스코프가 끝나면 섀도잉이 사라집니다.

```move
let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
```

지역 변수는 섀도잉될 때 타입을 변경할 수 있다는 것을 기억하세요.

```move
let x = 0;
{
    let x = b"hello";
    assert!(x = b"hello", 42);
};
assert!(x == 0, 42);
```

## Move와 Copy

Move의 모든 지역 변수는 `move` 또는 `copy`의 두 가지 방법으로 사용될 수 있습니다. 둘 중 하나가 지정되지 않으면 Move 컴파일러는 `copy` 또는 `move`를 사용해야 하는지 추론할 수 있습니다.
이는 위의 모든 예제에서 컴파일러가 `move` 또는 `copy`를 삽입했음을 의미합니다. 지역 변수는 `move` 또는 `copy` 사용 없이는 사용할 수 없습니다.

`copy`는 다른 프로그래밍 언어에서 온 것처럼 가장 친숙하게 느껴질 것입니다. 표현식에서 사용하기 위해 변수 내부의 값의 새 복사본을 만들기 때문입니다. `copy`를 사용하면 지역 변수를 두 번 이상 사용할 수 있습니다.

```move
let x = 0;
let y = copy x + 1;
let z = copy x + 2;
```

`copy` [ability](./abilities)가 있는 모든 값은 이런 방식으로 복사할 수 있으며, `move`가 지정되지 않는 한 암시적으로 복사됩니다.

`move`는 데이터를 복사하지 _않고_ 지역 변수에서 값을 꺼냅니다. `move`가 발생한 후에는 값의 타입이 `copy` [ability](./abilities)를 가지고 있더라도 지역 변수를 사용할 수 없습니다.

```move
let x = 1;
// highlight-error-start
let y = move x + 1;
//      ------ 지역 변수가 여기서 이동됨
let z = move x + 2; // Error!
//      ^^^^^^ 지역 변수 'x'의 잘못된 사용
// highlight-error-end
y + z
```

### 안전성

Move의 타입 시스템은 값이 이동된 후 사용되는 것을 방지합니다. 이는 지역 변수가 값이 할당되기 전에 사용되는 것을 방지하는 [`let` 선언](#let-bindings)에서 설명된 것과 동일한 안전성 검사입니다.

{/* 자세한 정보는 TODO 향후 소유권 및 move 의미론 섹션을 참조하세요. */}

### 추론

위에서 언급했듯이, Move 컴파일러는 하나가 표시되지 않은 경우 `copy` 또는 `move`를 추론합니다. 이를 수행하는 알고리즘은 매우 간단합니다:

- `copy` [ability](./abilities)가 있는 모든 값에는 `copy`가 부여됩니다.
- 모든 참조(가변 `&mut` 및 불변 `&` 모두)에는 `copy`가 부여됩니다.
  - 예측 가능한 차용 검사기 오류를 위해 `move`로 만들어지는 특별한 상황을 제외하고. 이는 참조가 더 이상 사용되지 않으면 발생합니다.
- 다른 모든 값에는 `move`가 부여됩니다.

다음 구조체가 주어졌을 때

```move
public struct Foo has copy, drop, store { f: u64 }
public struct Coin has store { value: u64 }
```

다음 예제가 있습니다

```move
let s = b"hello";
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };
let coins = vector[Coin { value: 0 }, Coin { value: 0 }];

let s2 = s; // copy
let foo2 = foo; // copy
let coin2 = coin; // move
let coins2 = coin; // move

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &x;
let coin_ref = &mut coin2;

let x2 = x; // copy
let b2 = b; // copy
let addr2 = @0x42; // copy
let x_ref2 = x_ref; // copy
let coin_ref2 = coin_ref; // copy
```