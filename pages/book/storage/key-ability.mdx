# Key Ability

[기본 문법](./../move-basics) 챕터에서 이미 네 가지 ability 중 두 가지인
[Drop](./../move-basics/drop-ability)과 [Copy](./../move-basics/copy-ability)를 다뤘습니다. 이들은
스코프 내에서 값의 동작에 영향을 미치며 스토리지와 직접적인 관련이 없습니다. 이제 struct를 저장할 수 있게 하는
`key` ability를 다룰 차례입니다.

역사적으로 `key` ability는 타입을 _스토리지의 키_로 표시하기 위해 만들어졌습니다. `key`
ability를 가진 타입은 스토리지의 최상위 레벨에 저장될 수 있고, 계정이나 주소에 의해
_직접 소유_될 수 있었습니다. [Object Model](./../object)의 도입과 함께, `key` ability는
자연스럽게 object를 정의하는 ability가 되었습니다.

{/* TODO: Sui Verifier가 무엇인지 - 링크, 나중에 */}

## Object 정의

`key` ability를 가진 struct는 object로 간주되며 스토리지 함수에서 사용할 수 있습니다.
Sui Verifier는 struct의 첫 번째 필드가 `id`라는 이름을 가지고 `UID` 타입을
가져야 한다고 요구합니다.

```move
public struct Object has key {
    id: UID, // 필수
    name: String,
}

/// 고유 ID를 가진 새로운 Object를 생성합니다
public fun new(name: String, ctx: &mut TxContext): Object {
    Object {
        id: object::new(ctx), // 새로운 UID를 생성합니다
        name,
    }
}
```

`key` ability를 가진 struct는 여전히 struct이며, 원하는 만큼의 필드와 관련
함수를 가질 수 있습니다. struct를 패킹, 접근 또는 언패킹하는 데 특별한 처리나 구문이 없습니다.

그러나 object struct의 첫 번째 필드는 복사할 수 없고 폐기할 수 없는 타입인 `UID` 타입이어야 하므로
(곧 다룰 예정입니다!), struct는 전이적으로 `drop`과
`copy` ability를 가질 수 없습니다. 따라서 object는 설계상 폐기할 수 없습니다.

{/* ## 자산 정의

[Object Model](./../object/digital-assets)의 맥락에서, `key` ability를 가진 object는 자산으로 간주될 수 있습니다. 폐기할 수 없고, 고유하며, *소유*될 수 있습니다.
 */}

## `key` Ability를 가진 타입들

`key`를 가진 타입에 대한 `UID` 요구사항 때문에, Move의 네이티브 타입은 `key`
ability를 가질 수 없으며, [표준 라이브러리](./../move-basics/standard-library) 타입도 마찬가지입니다.
`key` ability는 [Sui 프레임워크](./../programmability/sui-framework)와 사용자 정의
타입에만 존재합니다.

## 다음 단계

Key ability는 Move에서 object를 정의하며, object는 _저장_되도록 의도되었습니다. 다음 섹션에서는
object를 위한 네이티브 스토리지 함수를 제공하는 `sui::transfer` module을 소개합니다.

## 추가 자료

- Move Reference의 [Type Abilities](./../../reference/abilities)
