# 제한된 전송과 공개 전송

[이전 섹션](./storage-functions)에서 설명한 스토리지 작업들은
기본적으로 제한됩니다 - object를 정의한 module에서만 호출할 수 있습니다. 다시 말해,
타입이 스토리지 작업에 사용되려면 module에 *내부적*이어야 합니다. 이 제한은
Sui Verifier에 구현되어 있으며 바이트코드 수준에서 적용됩니다.

그러나 object가 다른 module에서 전송되고 저장될 수 있도록 하기 위해 이러한 제한을
완화할 수 있습니다. `sui::transfer` module은 다른 module에서 스토리지 작업을 호출할 수 있게 하는
_public\_\*_ 함수 세트를 제공합니다. 이 함수들은 `public_` 접두사가 붙어 있으며
모든 module과 트랜잭션에서 사용할 수 있습니다.

## 공개 스토리지 작업

`sui::transfer` module은 다음과 같은 public 함수들을 제공합니다. 이들은 이미 다룬 함수들과
거의 동일하지만, 모든 module에서 호출할 수 있습니다.

```move
module sui::transfer;

/// `transfer` 함수의 public 버전.
public fun public_transfer<T: key + store>(object: T, to: address) {}

/// `share_object` 함수의 public 버전.
public fun public_share_object<T: key + store>(object: T) {}

/// `freeze_object` 함수의 public 버전.
public fun public_freeze_object<T: key + store>(object: T) {}
```

이러한 함수들의 사용을 설명하기 위해 다음 예제를 고려해보겠습니다: module A는
`key`를 가진 ObjectK와 `key + store` ability를 가진 ObjectKS를 정의하고, module B는
이 object들에 대한 `transfer` 함수를 구현하려고 시도합니다.

> 이 예제에서는 `transfer::transfer`를 사용하지만, `share_object`와
> `freeze_object` 함수들도 동일한 동작을 합니다.

```move
/// `key`와 `key + store` ability를 각각 가진
/// `ObjectK`와 `ObjectKS`를 정의합니다
module book::transfer_a;

public struct ObjectK has key { id: UID }
public struct ObjectKS has key, store { id: UID }
```

```move
/// `transfer_a`에서 `ObjectK`와 `ObjectKS` 타입을 가져와서
/// 이들에 대한 다른 `transfer` 함수들을 구현하려고 시도합니다
module book::transfer_b;

// 타입들은 이 module에 내부적이지 않습니다
use book::transfer_a::{ObjectK, ObjectKS};

// 실패! ObjectK는 `store`가 없고, ObjectK는 이 module에 내부적이지 않습니다
public fun transfer_k(k: ObjectK, to: address) {
    sui::transfer::transfer(k, to);
}

// 실패! ObjectKS는 `store`를 가지지만 함수가 public이 아닙니다
public fun transfer_ks(ks: ObjectKS, to: address) {
    sui::transfer::transfer(ks, to);
}

// 실패! ObjectK는 `store`가 없습니다, `public_transfer`는 `store`를 요구합니다
public fun public_transfer_k(k: ObjectK) {
    sui::transfer::public_transfer(k);
}

// 성공! ObjectKS는 `store`를 가지고 함수가 public입니다
public fun public_transfer_ks(y: ObjectKS, to: address) {
    sui::transfer::public_transfer(y, to);
}
```

위 예제를 확장하면:

- ❌ `transfer_k`는 ObjectK가 `transfer_b` module에 내부적이지 않기 때문에 실패합니다
- ❌ `transfer_ks`는 ObjectKS가 `transfer_b` module에 내부적이지 않기 때문에 실패합니다
- ❌ `public_transfer_k`는 ObjectK가 `store` ability를 가지지 않기 때문에 실패합니다
- ✅ `public_transfer_ks`는 ObjectKS가 `store` ability를 가지고 전송이 public이기 때문에 성공합니다

## `store`의 의미

타입에 `store` ability를 추가할지에 대한 결정은 신중하게 내려야 합니다. 한편으로는,
타입이 다른 애플리케이션에서 *사용 가능*하기 위한 사실상의 요구사항입니다. 다른 한편으로는,
*감싸기*와 의도된 스토리지 모델을 변경하는 것을 허용합니다. 예를 들어, 캐릭터는
계정이 소유하도록 의도될 수 있지만, `store` ability를 가지면 동결될 수 있습니다
(공유될 수 없음 - 이 전환은 제한됩니다).
