# 스토리지 함수

주요 스토리지 작업을 정의하는 module은 `sui::transfer`입니다. 이는 [Sui 프레임워크](./../programmability/sui-framework)에
의존하는 모든 패키지에서 암시적으로 가져오므로, 다른 암시적으로 가져온 module(예: `std::option` 또는 `std::vector`)과 마찬가지로
use 문을 추가할 필요가 없습니다.

## 개요

`transfer` module은 우리가 설명한 [소유권 타입](./../object/ownership)과 일치하는 세 가지 스토리지
작업을 수행하는 함수를 제공합니다:

> 이 페이지에서는 소위 _제한된_ 스토리지 작업에 대해서만 이야기하고, 나중에 `store` ability가
> 도입된 후 _공개_ 작업을 다룰 것입니다.

1. _전송(Transfer)_ - object를 주소로 보내어 _계정 소유_ 상태로 만듭니다;
2. _공유(Share)_ - object를 _공유_ 상태로 만들어 모든 사람이 사용할 수 있게 합니다;
3. _동결(Freeze)_ - object를 _불변_ 상태로 만들어 공개 상수가 되고 결코 변경할 수 없게
   합니다.

`transfer` module은 다음 챕터에서 다룰 [동적 필드](./../programmability/dynamic-fields)의
특별한 경우를 제외하고 대부분의 스토리지 작업을 위한 기본 module입니다.

## 소유권과 참조: 빠른 복습

[소유권과 스코프](./../move-basics/ownership-and-scope)와
[참조](./../move-basics/references) 챕터에서 Move의 소유권과 참조의 기본을 다뤘습니다.
스토리지 함수를 사용할 때 이러한 개념을 이해하는 것이 중요합니다.
가장 중요한 점들을 빠르게 복습해보겠습니다:

- Move의 _이동_ 의미론은 값이 한 스코프에서 다른 스코프로 _이동_된다는 것을 의미합니다. 다시 말해,
  타입의 인스턴스가 함수에 _값으로_ 전달되면 함수 스코프로 _이동_되어 호출자 스코프에서 더 이상
  접근할 수 없습니다.
- 값의 소유권을 유지하려면 _참조로_ 전달할 수 있습니다. _불변 참조_ `&T` 또는 _가변 참조_ `&mut T`로
  전달합니다. 그러면 값이 _빌려지고_ 호출된 스코프에서 접근할 수 있지만 소유자는 동일하게
  유지됩니다.

```move
/// 값으로 이동됨
public fun take<T>(value: T) { /* 값이 여기로 이동됨! */ abort 0 }

/// 불변 참조용
public fun borrow<T>(value: &T) { /* 값이 여기서 빌려짐! 읽을 수 있음 */ abort 0 }

/// 가변 참조용
public fun borrow_mut<T>(value: &mut T) { /* 값이 가변으로 빌려짐! */ abort 0 }
```

{/* TODO 부분:
    - object는 연관된 스토리지 타입을 가지지 않음
    - 동일한 타입의 object도 다르게 저장될 수 있음
    - 트랜잭션에서 object는 ID로 지정되어야 함
 */}

## 전송(Transfer)

`transfer::transfer` 함수는 object를 다른 주소로 전송하는 데 사용되는 public 함수입니다.
함수 시그니처는 다음과 같으며, [`key` ability](./key-ability)를 가진 타입과
수신자의 [주소](./../move-basics/address)만 받습니다. object가 함수에 _값으로_ 전달되므로
함수 스코프로 _이동_된 다음 수신자 주소로 이동된다는 점에 주의하세요:

```move
module sui::transfer;

public fun transfer<T: key>(obj: T, recipient: address);
```

다음 예제에서는 object를 정의하고 트랜잭션 발신자에게 보내는 module에서
어떻게 사용할 수 있는지 볼 수 있습니다.

```move
module book::transfer_to_sender;

/// `key`를 가진 struct는 object입니다. 첫 번째 필드는 `id: UID`입니다!
public struct AdminCap has key { id: UID }

/// `init` 함수는 module이 배포될 때 호출되는 특별한 함수입니다.
/// 애플리케이션 object를 생성하기에 좋은 장소입니다.
fun init(ctx: &mut TxContext) {
    // 이 스코프에서 새로운 `AdminCap` object를 생성합니다.
    let admin_cap = AdminCap { id: object::new(ctx) };

    // object를 트랜잭션 발신자에게 전송합니다.
    transfer::transfer(admin_cap, ctx.sender());

    // admin_cap은 사라졌습니다! 더 이상 접근할 수 없습니다.
}

/// `AdminCap` object를 `recipient`에게 전송합니다. 따라서 수신자가
/// object의 소유자가 되고, 오직 그들만 접근할 수 있습니다.
public fun transfer_admin_cap(cap: AdminCap, recipient: address) {
    transfer::transfer(cap, recipient);
}
```

module이 배포되면 `init` 함수가 호출되고, 그곳에서 생성한 `AdminCap` object가
트랜잭션 발신자에게 _전송_됩니다. `ctx.sender()` 함수는
현재 트랜잭션의 발신자 주소를 반환합니다.

`AdminCap`이 발신자에게 전송되면, 예를 들어 `0xa11ce`에게 전송되면, 발신자만이
object에 접근할 수 있습니다. object는 이제 _계정 소유_됩니다.

> 계정 소유 object는 _진정한 소유권_의 대상입니다 - 오직 계정 소유자만 접근할 수 있습니다.
> 이는 Sui 스토리지 모델의 기본 개념입니다.

`AdminCap`을 사용하여 새 object의 발행과 다른 주소로의 전송을 승인하는 함수로
예제를 확장해 보겠습니다:

```move
/// 관리자가 `mint_and_transfer`할 수 있는 `Gift` object.
public struct Gift has key { id: UID }

/// 새로운 `Gift` object를 생성하고 `recipient`에게 전송합니다.
public fun mint_and_transfer(
    _: &AdminCap, recipient: address, ctx: &mut TxContext
) {
    let gift = Gift { id: object::new(ctx) };
    transfer::transfer(gift, recipient);
}
```

`mint_and_transfer` 함수는 "누구나" 호출할 수 있는 public 함수지만,
첫 번째 인자로 `AdminCap` object를 참조로 전달해야 합니다. 이것 없이는
함수를 호출할 수 없습니다. 이는 _[Capability](./../programmability/capability)_라고 불리는
권한이 필요한 함수에 대한 접근을 제한하는 간단한 방법입니다. `AdminCap` object가
_계정 소유_이므로, 오직 `0xa11ce`만 `mint_and_transfer` 함수를 호출할 수 있습니다.

수신자에게 전송된 `Gift`들도 _계정 소유_가 되며, 각 선물은 고유하고
수신자가 독점적으로 소유합니다.

빠른 정리:

- `transfer` 함수는 object를 주소로 보내는 데 사용됩니다;
- object는 _계정 소유_가 되어 오직 수신자만 접근할 수 있습니다;
- 함수는 object를 인자로 전달하도록 요구하여 게이트할 수 있으며,
  _capability_를 만듭니다.

## 동결(Freeze)

`transfer::freeze_object` 함수는 object를 _불변_ 상태로 만드는 데 사용되는
public 함수입니다. object가 _동결_되면 결코 변경할 수 없으며,
누구나 불변 참조로 접근할 수 있습니다.

함수 시그니처는 다음과 같으며, [`key` ability](./key-ability)를 가진 타입만
받습니다. 다른 모든 스토리지 함수와 마찬가지로 object를 _값으로_
받습니다:

```move
module sui::transfer;

public fun freeze_object<T: key>(obj: T);
```

이전 예제를 확장하여 관리자가 `Config` object를 생성하고
동결할 수 있는 함수를 추가해 보겠습니다:

```move
/// 관리자가 `create_and_freeze`할 수 있는 `Config` object.
public struct Config has key {
    id: UID,
    message: String
}

/// 새로운 `Config` object를 생성하고 동결합니다.
public fun create_and_freeze(
    _: &AdminCap,
    message: String,
    ctx: &mut TxContext
) {
    let config = Config {
        id: object::new(ctx),
        message
    };

    // object를 동결하여 불변이 되도록 합니다.
    transfer::freeze_object(config);
}

/// `Config` object에서 메시지를 반환합니다.
/// 불변 참조로 object에 접근할 수 있습니다!
public fun message(c: &Config): String { c.message }
```

Config는 `message` 필드를 가진 object이고, `create_and_freeze` 함수는 새로운
`Config`를 생성하고 동결합니다. object가 동결되면 누구나 불변
참조로 접근할 수 있습니다. `message` 함수는 `Config`
object에서 메시지를 반환하는 public 함수입니다. Config는 이제 ID로 공개적으로 사용 가능하며, 누구나 메시지를 읽을 수 있습니다.

> 함수 정의는 object의 상태와 연결되지 않습니다. 동결된 object에 가변 참조를 받는
> 함수를 정의할 수는 있지만, 동결된 object에서는 호출할 수 없습니다.

`message` 함수는 불변 `Config` object에서 호출할 수 있지만, 아래 두 함수는
동결된 object에서 호출할 수 없습니다:

```move
// === 아래 함수들은 동결된 object에서 호출할 수 없습니다! ===

/// 함수는 정의될 수 있지만, 동결된 object에서는 호출할 수 없습니다.
/// 오직 불변 참조만 허용됩니다.
public fun message_mut(c: &mut Config): &mut String { &mut c.message }

/// `Config` object를 삭제하며, 값으로 받습니다.
/// 동결된 object에서 호출할 수 없습니다!
public fun delete_config(c: Config) {
    let Config { id, message: _ } = c;
    id.delete()
}
```

요약하면:

- `transfer::freeze_object` 함수는 object를 _불변_ 상태로 만드는 데 사용됩니다;
- object가 _동결_되면 결코 변경, 삭제 또는 전송할 수 없으며, 누구나 불변 참조로
  접근할 수 있습니다;

## 소유 -> 동결

`transfer::freeze_object` 시그니처가 `key` ability를 가진 모든 타입을 받으므로,
같은 스코프에서 생성된 object도 받을 수 있고 계정이 소유한 object도
받을 수 있습니다. 이는 `freeze_object` 함수가 발신자에게 _전송_된 object를
_동결_하는 데 사용될 수 있다는 의미입니다. 보안 문제로, `AdminCap`
object를 동결하고 싶지 않을 것입니다 - 누구나 접근할 수 있게 하는 것은 보안 위험이 될 것입니다.
그러나 발행되어 수신자에게 전송된 `Gift` object는 동결할 수 있습니다:

> 단일 소유자 -> 불변 변환이 가능합니다!

```move
/// `Gift` object를 동결하여 불변이 되도록 합니다.
public fun freeze_gift(gift: Gift) {
    transfer::freeze_object(gift);
}
```

## 공유(Share)

`transfer::share_object` 함수는 object를 _공유_ 상태로 만드는 데 사용되는
public 함수입니다. object가 _공유_되면 누구나 가변 참조로 (따라서
불변 참조로도) 접근할 수 있습니다. 함수 시그니처는 다음과 같으며,
[`key` ability](./key-ability)를 가진 타입만 받습니다:

```move
module sui::transfer;

public fun share_object<T: key>(obj: T);
```

object가 _공유_되면 가변 참조로 공개적으로 사용할 수 있습니다.

## 특별한 경우: 공유 Object 삭제

공유 object는 일반적으로 값으로 가져올 수 없지만, 한 가지 특별한 경우가 있습니다 -
object를 가져오는 함수가 object를 삭제하는 경우입니다. 이는 Sui 스토리지 모델의 특별한 경우이며,
공유 object의 삭제를 허용하기 위해 사용됩니다. 어떻게 작동하는지 보여드리기 위해,
Config object를 생성하고 공유하는 함수와 이를 삭제하는 함수를 만들어 보겠습니다:

```move
/// 새로운 `Config` object를 생성하고 공유합니다.
public fun create_and_share(message: String, ctx: &mut TxContext) {
    let config = Config {
        id: object::new(ctx),
        message
    };

    // object를 공유하여 공유 상태가 되도록 합니다.
    transfer::share_object(config);
}
```

`create_and_share` 함수는 새로운 `Config` object를 생성하고 공유합니다. object는 이제
가변 참조로 공개적으로 사용할 수 있습니다. 공유 object를 삭제하는 함수를 만들어 보겠습니다:

```move
/// `Config` object를 삭제하며, 값으로 받습니다.
/// 공유 object에서 호출할 수 있습니다!
public fun delete_config(c: Config) {
    let Config { id, message: _ } = c;
    id.delete()
}
```

`delete_config` 함수는 `Config` object를 값으로 받아 삭제하며, Sui Verifier는
이 호출을 허용합니다. 하지만 함수가 `Config` object를 다시 반환하거나
`freeze` 또는 `transfer`하려고 시도하면 Sui Verifier는 트랜잭션을 거부합니다.

```move
// 작동하지 않습니다!
public fun transfer_shared(c: Config, to: address) {
    transfer::transfer(c, to);
}
```

요약하면:

- `share_object` 함수는 object를 _공유_ 상태로 만드는 데 사용됩니다;
- object가 _공유_되면 누구나 가변 참조로 접근할 수 있습니다;
- 공유 object는 삭제할 수 있지만 전송하거나 동결할 수 없습니다.

## 다음 단계

이제 `transfer` module의 주요 기능을 알았으므로, 스토리지 작업을 포함하는
더 복잡한 Sui 애플리케이션을 구축할 수 있습니다. 다음 챕터에서는
object 내부에 데이터를 저장할 수 있게 하고 여기서 거의 다루지 않은 전송 제한을
완화하는 [Store Ability](./store-ability)를 다룰 것입니다. 그리고 그 후에는
Sui 스토리지 모델에서 가장 중요한 타입인 [UID와 ID](./uid-and-id) 타입을 다룰 것입니다.
