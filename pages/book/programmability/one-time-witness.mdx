# One Time Witness

일반적인 [Witness](./witness-pattern)가 타입의 소유권을 정적으로 증명하는 좋은 방법이지만,
Witness가 단 한 번만 인스턴스화되도록 보장해야 하는 경우가 있습니다. 이것이 바로 
One Time Witness (OTW)의 목적입니다.

{/*
Notes to self:
  - background first or definition first - which one is better?
  - why would someone read this section?
  - if we removed the OTW from docs, then we should give definition first.
*/}

## 정의

OTW는 한 번만 사용할 수 있는 특별한 유형의 Witness입니다. 수동으로 생성할 수 없으며
모듈당 고유함이 보장됩니다. Sui 어댑터는 다음 규칙을 따르는 타입을 OTW로 취급합니다:

1. `drop` 능력만 가집니다.
2. 필드가 없습니다.
3. 제네릭 타입이 아닙니다.
4. 모든 대문자로 모듈 이름을 따서 명명됩니다.

다음은 OTW의 예시입니다:

```move
module book::one_time;

/// `book::one_time` 모듈의 OTW입니다.
/// drop만 있고, 필드 없음, 제네릭 없음, 모두 대문자입니다.
public struct ONE_TIME has drop {}

/// `ONE_TIME`의 인스턴스를 첫 번째 인자로 받습니다.
fun init(otw: ONE_TIME, ctx: &mut TxContext) {
    // OTW로 무언가를 수행합니다
}
```

OTW는 수동으로 구성할 수 없으며, 그렇게 하려는 코드는
컴파일 오류를 발생시킵니다. OTW는
[모듈 초기화자](./module-initializer)에서 첫 번째 인자로 받을 수 있습니다. 그리고 `init` 함수는 모듈당
한 번만 호출되므로 OTW는 한 번만 인스턴스화되는 것이 보장됩니다.

## OTW 강제하기

타입이 OTW인지 확인하려면 [Sui 프레임워크](./sui-framework)의 `sui::types` 모듈이
타입이 OTW인지 확인하는 데 사용할 수 있는 특별한 함수 `is_one_time_witness`를 제공합니다.

```move
use sui::types;

const ENotOneTimeWitness: u64 = 1;

/// OTW를 인자로 받고, 타입이 OTW가 아니면 중단합니다.
public fun takes_witness<T: drop>(otw: T) {
    assert!(types::is_one_time_witness(&otw), ENotOneTimeWitness);
}
```

{/* ## Background

Before we get to actual definition of the OTW, let's consider a simple example. We want to build a generic implementation of a Coin type, which can be initialized with a witness. A instance of a witness `T` is used to create a new `TreasuryCap<T>` which is then used to mint a new `Coin<T>`.

```move
module book::simple_coin {

    /// Controls the supply of the Coin.
    public struct TreasuryCap<phantom T> has key, store {
        id: UID,
        total_supply: u64,
    }

    /// The Coin type where the `T` is a witness.
    public struct Coin<phantom T> has key, store {
        id: UID,
        value: u64,
    }

    /// Create a new TreasuryCap with a witness.
    /// Vulnerable: we can create multiple TreasuryCap<T> with the same witness.
    public fun new<T: drop>(_: T, ctx: &mut TxContext): TreasuryCap<T> {
        TreasuryCap { id: object::new(ctx), total_supply: 0 }
    }

    /// We use a regular witness to authorize the minting.
    public fun mint<T>(
        treasury: &mut TreasuryCap<T>,
        value: u64,
        ctx: &mut TxContext
    ) {
        treasury.total_supply = treasury.total_supply + value;
        Coin { id: object::new(ctx), value }
    }
}
```

A dishonest developer would be able to create multiple `TreasuryCap`s with the same witness, and mint more `Coin`s than expected. Here is an example of such a malicious module:

```move
module book::simple_coin_cheater {
    /// The Coin witness.
    public struct Move has drop {}

    /// Initialize the TreasuryCap with the Move witness.
    /// ...and do it twice! >_<
    fun init(ctx: &mut TxContext) {
        let treasury_cap = book::simple_coin::new(Move {}, ctx);
        let secret_treasury = book::simple_coin::new(Move {}, ctx);

        transfer::public_transfer(treasury_cap, ctx.sender())
        transfer::public_transfer(secret_treasury, ctx.sender())
    }
}

```

The example above has no protection against issuing multiple `TreasuryCap`s with the same witness, and in real-world application, this creates a problem of trust. If it was a human decision to support a Coin based on this implementation, they would have to make sure that:

- there is only one `TreasuryCap` for a given `T`.
- the module cannot be upgraded to issue more `TreasuryCap`s.
- the module code does not contain any backdoors to issue more `TreasuryCap`s.

However, it is not possible to check any of these conditions inside the Move code. And to prevent the need for trust, Sui introduces the OTW pattern.

## Solving the Coin Problem

To solve the case of multiple `TreasuryCap`s, we can use the OTW pattern. By defining the `COIN_OTW` type as an OTW, we can ensure that the `COIN_OTW` is used only once. The `COIN_OTW` is then used to create a new `TreasuryCap` and mint a new `Coin`.

```move

With

```move
module book::coin_otw {

    /// The OTW for the `book::coin_otw` module.
    struct COIN_OTW has drop {}

    /// Receive the instance of `COIN_OTW` as the first argument.
    fun init(otw: COIN_OTW, ctx: &mut TxContext) {
        let treasury_cap = book::simple_coin::new(COIN_OTW {}, ctx);
        transfer::public_transfer(treasury_cap, ctx.sender())
    }
}
```


 */}

{/* ## Case Study: Coin

TODO: add a story behind TreasuryCap and Coin

*/}

## 요약

OTW 패턴은 타입이 한 번만 사용되도록 보장하는 훌륭한 방법입니다. 대부분의 개발자는
OTW를 정의하고 받는 방법을 이해해야 하며, OTW 검사와 강제는 주로
라이브러리와 프레임워크에서 필요합니다. 예를 들어, `sui::coin` 모듈은
`coin::create_currency` 메서드에서 OTW를 요구하여 `coin::TreasuryCap`이 단 한 번만 생성되도록
강제합니다.

OTW는 다음 섹션에서 다룰 [Publisher](./publisher) object의 기반을 마련하는 강력한 도구입니다.

{/*

## Questions
- What other ways could be used to prevent multiple `TreasuryCap`s?
- Are there any other ways to use the OTW?

 */}
