# 참조

{/*

Chapter: Basic Syntax
Goal: Show what the borrow checker is and how it works.
Notes:
    - give the metro pass example
    - show why passing by reference is useful
    - mention that reference comparison is faster
    - references can be both mutable and immutable
    - immutable access to shared objects is faster
    - implicit copy
    - moving the value
    - unpacking a reference (mutable and immutable)

 */}

[소유권과 스코프](./ownership-and-scope) 섹션에서 값이 함수에 전달될 때 함수의 스코프로 _이동(move)_ 된다고 설명했습니다. 이는 함수가 값의 소유자가 되고, 원래 스코프(소유자)는 더 이상 그것을 사용할 수 없다는 의미입니다. 이는 값이 동시에 여러 곳에서 사용되지 않도록 보장하는 Move의 중요한 개념입니다. 하지만 값을 함수에 전달하면서도 소유권을 유지하고 싶은 사용 사례가 있습니다. 여기서 참조가 필요합니다.

이를 설명하기 위해 간단한 예를 들어보겠습니다 - 지하철 패스 애플리케이션입니다. 카드가 다음과 같이 사용될 수 있는 4가지 시나리오를 살펴보겠습니다:

1. 고정 가격으로 키오스크에서 구매
2. 승객이 유효한 패스를 가지고 있음을 증명하기 위해 검사원에게 보여주기
3. 지하철에 들어가기 위해 개찰구에서 사용하고 탑승권 구매
4. 비어있을 때 재활용

## 레이아웃

지하철 패스 애플리케이션의 초기 레이아웃은 간단합니다. `Card` 타입과 단일 카드의 탑승 횟수를 나타내는 `USES` [상수](./constants)를 정의합니다. 또한 카드가 비어있을 때를 위한 [오류 상수](./assert-and-abort#error-constants)도 추가합니다.

```move
module book::metro_pass;

/// 카드가 비어있을 때의 오류 코드.
const ENoUses: u64 = 0;

/// 지하철 패스 카드의 사용 횟수.
const USES: u8 = 3;

/// 지하철 패스 카드
public struct Card { uses: u8 }

/// 지하철 패스 카드를 구매합니다.
public fun purchase(/* Coin을 전달 */): Card {
    Card { uses: USES }
}
```

{/* In [the previous section](./ownership-and-scope) we explained the ownership and scope in Move. We showed how the value is *moved* to a new scope, and how it changes the owner. In this section, we will explain how to *borrow* a reference to a value to avoid moving it, and how Move's *borrow checker* ensures that the references are used correctly. */}

## 참조

참조는 소유권을 포기하지 않고 함수에 값을 _보여주는_ 방법입니다. 우리의 경우, 검사원에게 카드를 보여줄 때 소유권을 포기하고 싶지 않으며, 검사원이 우리의 탑승권을 사용하는 것을 허용하지 않습니다. 우리는 단지 카드 값의 _읽기_ 와 소유권 증명만을 허용하고 싶습니다.

이를 위해 함수 시그니처에서 `&` 기호를 사용하여 값 자체가 아닌 값에 대한 _참조_ 를 전달하고 있음을 나타냅니다.

```move
/// 지하철 패스 카드를 검사원에게 보여줍니다.
public fun is_valid(card: &Card): bool {
    card.uses > 0
}
```

함수가 카드의 소유권을 가지지 않기 때문에 데이터를 _읽을_ 수는 있지만 _쓸_ 수는 없습니다. 즉, 탑승 횟수를 수정할 수 없습니다. 또한 함수 시그니처는 카드 인스턴스 없이는 호출할 수 없도록 보장합니다. 이는 다음 챕터에서 다룰 [Capability 패턴](./../programmability/capability)을 가능하게 하는 중요한 속성입니다.

값에 대한 참조를 만드는 것은 종종 값을 "빌리는(borrowing)" 것으로 언급됩니다. 예를 들어, `Option`으로 감싸진 값에 대한 참조를 얻는 메서드는 `borrow`라고 합니다.

## 가변 참조

일부 경우에는 함수가 카드를 수정할 수 있도록 허용하고 싶습니다. 예를 들어, 개찰구에서 카드를 사용할 때 탑승권을 차감해야 합니다. 이를 위해 함수 시그니처에서 `&mut` 키워드를 사용합니다.

```move
/// 지하철에 들어가기 위해 개찰구에서 지하철 패스 카드를 사용합니다.
public fun enter_metro(card: &mut Card) {
    assert!(card.uses > 0, ENoUses);
    card.uses = card.uses - 1;
}
```

함수 본문에서 볼 수 있듯이 `&mut` 참조는 값을 변경할 수 있게 하며, 함수는 탑승권을 사용할 수 있습니다.

## 값으로 전달하기

마지막으로, 값 자체를 함수에 전달할 때 어떤 일이 일어나는지 살펴보겠습니다. 이 경우 함수가 값의 소유권을 가져가서 원래 스코프에서 접근할 수 없게 됩니다. 카드의 소유자는 카드를 재활용하여 함수에 소유권을 포기할 수 있습니다.

```move
/// 지하철 패스 카드를 재활용합니다.
public fun recycle(card: Card) {
    assert!(card.uses == 0, ENoUses);
    let Card { uses: _ } = card;
}
```

`recycle` 함수에서 카드는 값으로 전달되어 함수에 소유권이 이전됩니다. 이를 통해 언팩하고 파괴할 수 있습니다.

> 참고: Move에서 `_`는 값을 소비하면서도 필드를 무시하는 데 사용되는 와일드카드 패턴입니다. 분해는 struct 타입의 모든 필드와 일치해야 합니다. struct에 필드가 있다면 모든 필드를 명시적으로 나열하거나 `_`를 사용하여 원하지 않는 필드를 무시해야 합니다.

## 전체 예제

애플리케이션의 전체 흐름을 설명하기 위해 테스트에서 모든 부분을 합쳐 보겠습니다.

```move
#[test]
fun test_card_2024() {
    // 수정할 것이므로 변수를 가변으로 선언합니다
    let mut card = purchase();

    card.enter_metro(); // 카드를 수정하지만 이동시키지 않습니다
    assert!(card.is_valid()); // 카드를 읽습니다!

    card.enter_metro(); // 카드를 수정하지만 이동시키지 않습니다
    card.enter_metro(); // 카드를 수정하지만 이동시키지 않습니다

    card.recycle(); // 카드를 스코프 밖으로 이동시킵니다
}
```

## 추가 자료

- Move Reference의 [References](https://move-book.com/reference/primitive-types/references.html)

{/* ## Dereference and Copy */}

{/* TODO: defer and copy, *& */}

{/* ## Notes */}

{/*
    Move 2024 is great but it's better to show the example with explicit &t and &mut t
    ...and then say that the example could be rewritten with the new syntax


*/}

{/* ## Move 2024

Here's the test from this page written with the Move 2024 syntax:

```move file=packages/samples/sources/move-basics/references.move anchor=move_2024
```
*/}