# 기본 타입

{/* TODO: Shall we split this into two pages? Maybe give an overview and focus more on specifics? */}

단순 값의 경우, Move는 여러 내장 기본 타입을 가지고 있습니다. 이들은 다른 모든 타입의 기초입니다. 기본 타입은 다음과 같습니다:

- [불리언](#불리언)
- [부호 없는 정수](#정수-타입)
- [주소](./address) - 다음 섹션에서 다룹니다

기본 타입을 살펴보기 전에, 먼저 Move에서 변수를 선언하고 할당하는 방법을 알아봅시다.

## 변수와 할당

변수는 `let` 키워드를 사용하여 선언됩니다. 기본적으로 불변이지만, `mut` 키워드를 추가하여 가변으로 만들 수 있습니다:

```
let <variable_name>[: <type>]  = <expression>;
let mut <variable_name>[: <type>] = <expression>;
```

여기서:

- `<variable_name>` - 변수의 이름
- `<type>` - 변수의 타입, 선택사항
- `<expression>` - 변수에 할당될 값

```move
let x: bool = true;
let mut y: u8 = 42;
```

가변 변수는 `=` 연산자를 사용하여 재할당할 수 있습니다.

```move
y = 43;
```

변수는 재선언하여 섀도잉될 수도 있습니다.

```move
let x: u8 = 42;
let x: u16 = 42;
```

## 불리언

`bool` 타입은 불리언 값을 나타냅니다 - 예 또는 아니오, 참 또는 거짓. 두 가지 가능한 값이 있습니다: `true`와 `false`, 이들은 Move의 키워드입니다. 불리언의 경우, 컴파일러는 항상 값에서 타입을 추론할 수 있으므로 명시적으로 지정할 필요가 없습니다.

```move
let x = true;
let y = false;
```

불리언은 플래그를 저장하고 프로그램의 흐름을 제어하는 데 자주 사용됩니다. 자세한 내용은 [제어 흐름](./control-flow) 섹션을 참조하세요.

## 정수 타입

Move는 8비트에서 256비트까지 다양한 크기의 부호 없는 정수를 지원합니다. 정수 타입은 다음과 같습니다:

- `u8` - 8비트
- `u16` - 16비트
- `u32` - 32비트
- `u64` - 64비트
- `u128` - 128비트
- `u256` - 256비트

```move
let x: u8 = 42;
let y: u16 = 42;
// ...
let z: u256 = 42;
```

`true`와 `false` 같은 불리언 리터럴은 명확히 불리언이지만, `42` 같은 정수 리터럴은 어떤 정수 타입이든 될 수 있습니다. 대부분의 경우 컴파일러는 값에서 타입을 추론하며, 일반적으로 `u64`가 기본값입니다. 그러나 때때로 컴파일러가 타입을 추론할 수 없어 명시적인 타입 주석이 필요합니다. 할당 중에 제공하거나 타입 접미사를 사용하여 제공할 수 있습니다.

```move
// Both are equivalent
let x: u8 = 42;
let x = 42u8;
```

### 연산

Move는 정수에 대한 표준 산술 연산을 지원합니다: 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지. 이러한 연산의 구문은 다음과 같습니다:

| 구문 | 연산         | 중단되는 경우                         |
| ---- | ------------ | ------------------------------------- |
| +    | 덧셈         | 결과가 정수 타입에 비해 너무 큰 경우 |
| -    | 뺄셈         | 결과가 0보다 작은 경우                |
| \*   | 곱셈         | 결과가 정수 타입에 비해 너무 큰 경우 |
| %    | 나머지       | 제수가 0인 경우                       |
| /    | 나눗셈(버림) | 제수가 0인 경우                       |

> 비트 연산을 포함한 더 많은 연산은 [Move 레퍼런스](./../../reference/primitive-types/integers#bitwise)를 참조하세요.

피연산자의 타입은 _반드시 일치해야_ 합니다. 그렇지 않으면 컴파일러가 오류를 발생시킵니다. 연산 결과는 피연산자와 동일한 타입이 됩니다. 다른 타입에 대해 연산을 수행하려면 피연산자를 동일한 타입으로 캐스팅해야 합니다.

{/* TODO: add examples + parentheses for arithmetic operations */}
{/* TODO: add bitwise operators */}

### `as`를 사용한 캐스팅

Move는 정수 타입 간의 명시적 캐스팅을 지원합니다. 구문은 다음과 같습니다:

```move
<expression> as <type>
```

모호함을 방지하기 위해 표현식 주위에 괄호가 필요할 수 있습니다:

```move
let x: u8 = 42;
let y: u16 = x as u16;
let z = 2 * (x as u16); // ambiguous, requires parentheses
```

오버플로우를 방지하는 더 복잡한 예:

```move
let x: u8 = 255;
let y: u8 = 255;
let z: u16 = (x as u16) + ((y as u16) * 2);
```

### 오버플로우

Move는 오버플로우/언더플로우를 지원하지 않습니다. 타입 범위를 벗어난 값을 생성하는 연산은 런타임 오류를 발생시킵니다. 이는 예기치 않은 동작을 방지하기 위한 안전 기능입니다.

```move
let x = 255u8;
let y = 1u8;

// 이것은 오류를 발생시킵니다
let z = x + y;
```

## 더 읽어보기

- Move 레퍼런스의 [Bool](./../../reference/primitive-types/bool)
- Move 레퍼런스의 [정수](./../../reference/primitive-types/integers)