# 더 나은 오류 처리

실행 중 abort가 발생하면 트랜잭션이 실패하고 abort 코드가 호출자에게 반환됩니다.
Move VM은 트랜잭션을 중단한 모듈 이름과 abort 코드를 반환합니다. 이 동작은
특히 단일 함수가 abort할 수 있는 같은 함수를 여러 번 호출할 때
트랜잭션 호출자에게 완전히 투명하지 않습니다. 이 경우 호출자는 어떤 호출이
트랜잭션을 중단했는지 알 수 없으며, 문제를 디버깅하거나 사용자에게 의미 있는 오류
메시지를 제공하기 어려울 것입니다.

```move
module book::module_a;

use book::module_b;

public fun do_something() {
    let field_1 = module_b::get_field(1); // 0으로 abort할 수 있음
    /* ... 많은 로직 ... */
    let field_2 = module_b::get_field(2); // 0으로 abort할 수 있음
    /* ... 더 많은 로직 ... */
    let field_3 = module_b::get_field(3); // 0으로 abort할 수 있음
}
```

위 예시는 단일 함수가 abort할 수 있는 여러 호출을 포함하는 경우를 보여줍니다.
`do_something` 함수의 호출자가 abort 코드 `0`을 받으면, 어떤 `module_b::get_field` 호출이
트랜잭션을 중단했는지 이해하기 어려울 것입니다. 이 문제를 해결하기 위해
오류 처리를 개선하는 데 사용할 수 있는 일반적인 패턴이 있습니다.

## 규칙 1: 모든 가능한 시나리오 처리하기

작업을 안전하게 수행할 수 있는지 여부를 나타내는 불리언 값을 반환하는
안전한 "확인" 함수를 제공하는 것이 좋은 관행으로 간주됩니다. `module_b`가 필드가 존재하는지
여부를 나타내는 불리언 값을 반환하는 `has_field` 함수를 제공한다면,
`do_something` 함수를 다음과 같이 다시 작성할 수 있습니다:

```move
module book::module_a;

use book::module_b;

const ENoField: u64 = 0;

public fun do_something() {
    assert!(module_b::has_field(1), ENoField);
    let field_1 = module_b::get_field(1);
    /* ... */
    assert!(module_b::has_field(2), ENoField);
    let field_2 = module_b::get_field(2);
    /* ... */
    assert!(module_b::has_field(3), ENoField);
    let field_3 = module_b::get_field(3);
}
```

`module_b::get_field`에 대한 각 호출 전에 사용자 정의 검사를 추가함으로써,
`module_a`의 개발자는 오류 처리를 제어할 수 있습니다. 그리고 이는 두 번째 규칙을 구현할 수 있게 합니다.

## 규칙 2: 다른 코드로 Abort하기

Abort 코드가 호출자 모듈에 의해 처리되면, 두 번째 방법은 다른 시나리오에 대해
다른 abort 코드를 사용하는 것입니다. 이렇게 하면 호출자 모듈이 사용자에게 의미 있는 오류 메시지를
제공할 수 있습니다. `module_a`를 다음과 같이 다시 작성할 수 있습니다:

```move
module book::module_a;

use book::module_b;

const ENoFieldA: u64 = 0;
const ENoFieldB: u64 = 1;
const ENoFieldC: u64 = 2;

public fun do_something() {
    assert!(module_b::has_field(1), ENoFieldA);
    let field_1 = module_b::get_field(1);
    /* ... */
    assert!(module_b::has_field(2), ENoFieldB);
    let field_2 = module_b::get_field(2);
    /* ... */
    assert!(module_b::has_field(3), ENoFieldC);
    let field_3 = module_b::get_field(3);
}
```

이제 호출자 모듈은 사용자에게 의미 있는 오류 메시지를 제공할 수 있습니다. 호출자가
abort 코드 `0`을 받으면 "필드 1이 존재하지 않습니다"로 번역할 수 있습니다. 호출자가
abort 코드 `1`을 받으면 "필드 2가 존재하지 않습니다"로 번역할 수 있습니다. 그리고 계속 이어집니다.

## 규칙 3: `assert` 대신 `bool` 반환하기

개발자는 종종 모든 조건을 검사하고 실행을 중단하는 공개 함수를 추가하고 싶은 유혹을 받습니다.
그러나 대신 불리언 값을 반환하는 함수를 만드는 것이 더 나은 관행입니다.
이렇게 하면 호출자 모듈이 오류를 처리하고 사용자에게 의미 있는 오류 메시지를
제공할 수 있습니다.

```move
module book::some_app_assert;

const ENotAuthorized: u64 = 0;

public fun do_a() {
    assert_is_authorized();
    // ...
}

public fun do_b() {
    assert_is_authorized();
    // ...
}

/// 이렇게 하지 마세요
public fun assert_is_authorized() {
    assert!(/* 어떤 조건 */ true, ENotAuthorized);
}
```

이 모듈은 다음과 같이 다시 작성할 수 있습니다:

```move
module book::some_app;

const ENotAuthorized: u64 = 0;

public fun do_a() {
    assert!(is_authorized(), ENotAuthorized);
    // ...
}

public fun do_b() {
    assert!(is_authorized(), ENotAuthorized);
    // ...
}

public fun is_authorized(): bool {
    /* 어떤 조건 */ true
}

// 같은 조건과 같은 abort 코드가 여러 곳에서 사용될 때
// 코드 중복을 피하기 위해 private 함수를 여전히 사용할 수 있습니다
fun assert_is_authorized() {
    assert!(is_authorized(), ENotAuthorized);
}
```

이 세 가지 규칙을 활용하면 트랜잭션 호출자에게 오류 처리가 더 투명해지고,
다른 개발자가 자신의 모듈에서 사용자 정의 abort 코드를 사용할 수 있게 됩니다.
