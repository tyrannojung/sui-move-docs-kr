# 코드 품질 체크리스트

Move 언어와 생태계의 빠른 발전으로 많은 오래된 관행들이 구식이 되었습니다. 이 가이드는 개발자들이 코드를 검토하고 Move 개발의 현재 모범 사례에 맞추도록 돕는 체크리스트 역할을 합니다. 주의 깊게 읽고 가능한 한 많은 권장사항을 코드에 적용해 주세요.

## 코드 구성

이 가이드에서 언급된 일부 문제들은 [Move Formatter](https://www.npmjs.com/package/@mysten/prettier-plugin-move)를 CLI 도구로 사용하거나, [CI 체크로](https://github.com/marketplace/actions/move-formatter), 또는 [VSCode (Cursor) 플러그인으로](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move) 사용하여 해결할 수 있습니다.

## 패키지 매니페스트

### 올바른 에디션 사용

이 가이드의 모든 기능은 Move 2024 에디션을 필요로 하며, 패키지 매니페스트에 명시되어야 합니다.

```toml
[package]
name = "my_package"
edition = "2024.beta" # 또는 (그냥) "2024"
```

### 암시적 프레임워크 의존성

Sui 1.45부터 `Move.toml`에 프레임워크 의존성을 명시할 필요가 없습니다:

```toml
# 구식, 1.45 이전
[dependencies]
Sui = { ... }

# 현재, Sui, Bridge, MoveStdlib, SuiSystem이 암시적으로 가져와집니다!
[dependencies]
```

### 명명된 주소에 접두사 추가

패키지가 일반적인 이름(예: `token`)을 가지고 있다면 – 특히 프로젝트에 여러 패키지가 포함되어 있다면 – 명명된 주소에 접두사를 추가하세요:

```toml
# 나쁨! 아무것도 나타내지 않고, 충돌할 수 있음
[addresses]
math = "0x0"

# 좋음! 프로젝트를 명확히 나타내고, 충돌 가능성이 낮음
[addresses]
my_protocol_math = "0x0"
```

## 가져오기, Module 및 상수

### Module 레이블 사용

```move
// 나쁨: 들여쓰기가 증가하고, 레거시 스타일
module my_package::my_module {
    public struct A {}
}

// 좋음!
module my_package::my_module;

public struct A {}
```

### `use` 문에서 단일 `Self` 사용 금지

```move
// 올바름, 멤버 + self 가져오기
use my_package::other::{Self, OtherMember};

// 나쁨! `{Self}`는 중복됨
use my_package::my_module::{Self};

// 좋음!
use my_package::my_module;
```

### `Self`와 함께 `use` 문 그룹화

```move
// 나쁨!
use my_package::my_module;
use my_package::my_module::OtherMember;

// 좋음!
use my_package::my_module::{Self, OtherMember};
```

### 에러 상수는 `EPascalCase`로

```move
// 나쁨! 대문자는 일반 상수에 사용됨
const NOT_AUTHORIZED: u64 = 0;

// 좋음! 에러 상수임을 명확히 표시
const ENotAuthorized: u64 = 0;
```

### 일반 상수는 `ALL_CAPS`로

```move
// 나쁨! PascalCase는 에러 상수와 연관됨
const MyConstant: vector<u8> = b"my const";

// 좋음! 상수값임을 명확히 표시
const MY_CONSTANT: vector<u8> = b"my const";
```

## 구조체

### Capability는 `Cap` 접미사 추가

```move
// 나쁨! capability라면 `Cap` 접미사를 추가하세요
public struct Admin has key, store {
    id: UID,
}

// 좋음! 리뷰어가 타입에서 기대하는 것을 알 수 있음
public struct AdminCap has key, store {
    id: UID,
}
```

### 이름에 `Potato` 사용 금지

```move
// 나쁨! ability가 없으므로 이미 Hot-Potato 타입임을 알 수 있음
public struct PromisePotato {}

// 좋음!
public struct Promise {}
```

### 이벤트는 과거형으로 명명

```move
// 나쁨! 이 구조체가 무엇을 하는지 명확하지 않음
public struct RegisterUser has copy, drop { user: address }

// 좋음! 이벤트임이 명확함
public struct UserRegistered has copy, drop { user: address }
```

### 동적 필드 키에는 위치 구조체 사용 + `Key` 접미사

```move
// 그리 나쁘지는 않지만, 표준 스타일에 반함
public struct DynamicField has copy, drop, store {}

// 좋음! 표준 스타일, Key 접미사
public struct DynamicFieldKey() has copy, drop, store;
```

## 함수

### `public entry` 금지, `public` 또는 `entry`만 사용

```move
// 나쁨! 트랜잭션에서 호출 가능하기 위해 entry가 필요하지 않음
public entry fun do_something() { /* ... */ }

// 좋음! public 함수가 더 유연하고, 값을 반환할 수 있음
public fun do_something_2(): T { /* ... */ }
```

### PTB를 위한 조합 가능한 함수 작성

```move
// 나쁨! 조합 불가능, 테스트하기 어려움!
public fun mint_and_transfer(ctx: &mut TxContext) {
    /* ... */
    transfer::transfer(nft, ctx.sender());
}

// 좋음! 조합 가능!
public fun mint(ctx: &mut TxContext): NFT { /* ... */ }

// 좋음! 의도적으로 조합 불가능
entry fun mint_and_keep(ctx: &mut TxContext) { /* ... */ }
```

### Object가 먼저 (Clock 제외)

```move
// 나쁨! 읽기 어려움!
public fun call_app(
    value: u8,
    app: &mut App,
    is_smth: bool,
    cap: &AppCap,
    clock: &Clock,
    ctx: &mut TxContext,
) { /* ... */ }

// 좋음!
public fun call_app(
    app: &mut App,
    cap: &AppCap,
    value: u8,
    is_smth: bool,
    clock: &Clock,
    ctx: &mut TxContext,
) { /* ... */ }
```

### Capability는 두 번째

```move
// 나쁨! 메서드 연관성을 깨뜨림
public fun authorize_action(cap: &AdminCap, app: &mut App) { /* ... */ }

// 좋음! 시그니처에서 Cap을 볼 수 있고 `.calls()`를 유지
public fun authorize_action(app: &mut App, cap: &AdminCap) { /* ... */ }
```

### Getter는 필드 이름 + `_mut`로 명명

```move
// 나쁨! 불필요한 `get_`
public fun get_name(u: &User): String { /* ... */ }

// 좋음! `name` 필드에 접근함이 명확함
public fun name(u: &User): String { /* ... */ }

// 좋음! 가변 참조에는 `_mut` 사용
public fun details_mut(u: &mut User): &mut Details { /* ... */ }
```

## 함수 본문: 구조체 메서드

### 일반적인 Coin 작업

```move
// 나쁨! 레거시 코드, 읽기 어려움!
let paid = coin::split(&mut payment, amount, ctx);
let balance = coin::into_balance(paid);

// 좋음! 구조체 메서드가 더 쉬움!
let balance = payment.split(amount, ctx).into_balance();

// 더 좋음 (이 예시에서 - 임시 코인을 만들 필요 없음)
let balance = payment.balance_mut().split(amount);

// 이것도 가능!
let coin = balance.into_coin(ctx);
```

### `std::string::utf8` 가져오기 금지

```move
// 나쁨! 안타깝게도 매우 흔함!
use std::string::utf8;

let str = utf8(b"hello, world!");

// 좋음!
let str = b"hello, world!".to_string();

// ASCII 문자열의 경우
let ascii = b"hello, world!".to_ascii_string();
```

### UID는 `delete` 메서드 사용

```move
// 나쁨!
object::delete(id);

// 좋음!
id.delete();
```

### `ctx`는 `sender()` 메서드 사용

```move
// 나쁨!
tx_context::sender(ctx);

// 좋음!
ctx.sender()
```

### Vector는 리터럴과 연관 함수 사용

```move
// 나쁨!
let mut my_vec = vector::empty();
vector::push_back(&mut my_vec, 10);
let first_el = vector::borrow(&my_vec);
assert!(vector::length(&my_vec) == 1);

// 좋음!
let mut my_vec = vector[10];
let first_el = my_vec[0];
assert!(my_vec.length() == 1);
```

### 컬렉션은 인덱스 문법 지원

```move
let x: VecMap<u8, String> = /* ... */;

// 나쁨!
x.get(&10);
x.get_mut(&10);

// 좋음!
&x[&10];
&mut x[&10];
```

## Option -> 매크로

### 파괴하고 함수 호출

```move
// 나쁨!
if (opt.is_some()) {
    let inner = opt.destroy_some();
    call_function(inner);
};

// 좋음! 매크로가 있습니다!
opt.do!(|value| call_function(value));
```

### 기본값으로 Some 파괴

```move
let opt = option::none();

// 나쁨!
let value = if (opt.is_some()) {
    opt.destroy_some()
} else {
    abort EError
};

// 좋음! 매크로가 있습니다!
let value = opt.destroy_or!(default_value);

// `none`에서 abort도 가능
let value = opt.destroy_or!(abort ECannotBeEmpty);
```

## 루프 -> 매크로

### N번 작업 수행

```move
// 나쁨! 읽기 어려움!
let mut i = 0;
while (i < 32) {
    do_action();
    i = i + 1;
};

// 좋음! 모든 uint가 이 매크로를 가짐!
32u8.do!(|_| do_action());
```

### 반복으로 새 Vector 생성

```move
// 읽기 어려움!
let mut i = 0;
let mut elements = vector[];
while (i < 32) {
    elements.push_back(i);
    i = i + 1;
};

// 읽기 쉬움!
vector::tabulate!(32, |i| i);
```

### Vector의 모든 요소에 작업 수행

```move
// 나쁨!
let mut i = 0;
while (i < vec.length()) {
    call_function(&vec[i]);
    i = i + 1;
};

// 좋음!
vec.do_ref!(|e| call_function(e));
```

### Vector 파괴하고 각 요소에 함수 호출

```move
// 나쁨!
while (!vec.is_empty()) {
    call(vec.pop_back());
};

// 좋음!
vec.destroy!(|e| call(e));
```

### Vector를 단일 값으로 접기

```move
// 나쁨!
let mut aggregate = 0;
let mut i = 0;

while (i < source.length()) {
    aggregate = aggregate + source[i];
    i = i + 1;
};

// 좋음!
let aggregate = source.fold!(0, |acc, v| {
    acc + v
});
```

### Vector의 요소 필터링

> 주의: `source` vector의 `T: drop`

```move
// 나쁨!
let mut filtered = [];
let mut i = 0;
while (i < source.length()) {
    if (source[i] > 10) {
        filtered.push_back(source[i]);
    };
    i = i + 1;
};

// 좋음!
let filtered = source.filter!(|e| e > 10);
```

## 기타

### 언팩에서 무시된 값은 완전히 무시 가능

```move
// 나쁨! 매우 희박함!
let MyStruct { id, field_1: _, field_2: _, field_3: _ } = value;
id.delete();

// 좋음! 2024 문법
let MyStruct { id, .. } = value;
id.delete();
```

## 테스팅

### `#[test]`와 `#[expected_failure(...)]` 병합

```move
// 나쁨!
#[test]
#[expected_failure]
fun value_passes_check() {
    abort
}

// 좋음!
#[test, expected_failure]
fun value_passes_check() {
    abort
}
```

### `expected_failure` 테스트 정리하지 않기

```move
// 나쁨! 정리가 필요 없음
#[test, expected_failure(abort_code = my_app::EIncorrectValue)]
fun try_take_missing_object_fail() {
    let mut test = test_scenario::begin(@0);
    my_app::call_function(test.ctx());
    test.end();
}

// 좋음! 테스트가 실패할 것으로 예상되는 지점이 명확함
#[test, expected_failure(abort_code = my_app::EIncorrectValue)]
fun try_take_missing_object_fail() {
    let mut test = test_scenario::begin(@0);
    my_app::call_function(test.ctx());

    abort // EIncorrectValue와 다름
}
```

### 테스팅 Module에서 테스트에 `test_` 접두사 사용 금지

```move
// 나쁨! module이 이미 _tests라고 불림
module my_package::my_module_tests;

#[test]
fun test_this_feature() { /* ... */ }

// 좋음! 결과적으로 더 나은 함수 이름
#[test]
fun this_feature_works() { /* ... */ }
```

### 필요하지 않은 곳에서 `TestScenario` 사용 금지

```move
// 나쁨! 필요 없음, ctx만 사용
let mut test = test_scenario::begin(@0);
let nft = app::mint(test.ctx());
app::destroy(nft);
test.end();

// 좋음! 간단한 경우를 위한 더미 컨텍스트가 있음
let ctx = &mut tx_context::dummy();
app::mint(ctx).destroy();
```

### 테스트에서 `assert!`에 중단 코드 사용 금지

```move
// 나쁨! 실수로 애플리케이션 에러 코드와 일치할 수 있음
assert!(is_success, 0);

// 좋음!
assert!(is_success);
```

### 가능한 한 `assert_eq!` 사용

```move
// 나쁨! 구식 스타일 코드
assert!(result == b"expected_value", 0);

// 좋음! 실패 시 두 값을 모두 출력
use std::unit_test::assert_eq;

assert_eq!(result, expected_value);
```

### "블랙홀" `destroy` 함수 사용

```move
// 나쁨!
nft.destroy_for_testing();
app.destroy_for_testing();

// 좋음! - 정리를 위한 특별한 함수를 정의할 필요 없음
use sui::test_utils::destroy;

destroy(nft);
destroy(app);
```

## 주석

### 문서 주석은 `///`로 시작

```move
// 나쁨! 도구가 JavaDoc 스타일 주석을 지원하지 않음
/**
 * Cool method
 * @param ...
 */
public fun do_something() { /* ... */ }

// 좋음! docgen과 IDE에서 문서 주석으로 렌더링됨
/// Cool method!
public fun do_something() { /* ... */ }
```

### 복잡한 로직? 주석 `//` 남기기

친절하게 리뷰어가 코드를 이해하도록 도와주세요!

```move
// 좋음!
// 주의: 값이 10보다 작으면 언더플로우가 발생할 수 있음.
// TODO: 여기에 `assert!` 추가
let value = external_call(value, ctx);
```