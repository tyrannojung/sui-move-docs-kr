# Move 2024 마이그레이션 가이드

Move 2024는 Mysten Labs에서 유지 관리하는 Move 언어의 새 버전입니다. 이 가이드는
2024 버전과 이전 버전의 Move 언어 간의 차이점을 이해하는 데 도움을 주기 위한 것입니다.

> 이 가이드는 새 버전의 변경 사항에 대한 개요를 제공합니다. 더 자세하고
> 완전한 변경 사항 목록은 [Sui 문서](https://docs.sui.io/guides/developer/advanced/move-2024-migration)를 참조하세요.

## 새 버전 사용하기

새 버전을 사용하려면 `move` 파일에서 버전을 지정해야 합니다. 버전은 `move` 파일에서
`edition` 키워드를 사용하여 지정됩니다. 현재 사용 가능한 버전은
`2024.beta`입니다.

```ini
edition = "2024"
# 또는 새로운 기능을 위해:
edition = "2024.beta"
```

## 마이그레이션 도구

Move CLI에는 코드를 새 버전으로 업데이트하는 마이그레이션 도구가 있습니다. 마이그레이션
도구를 사용하려면 다음 명령을 실행하세요:

```bash
$ sui move migrate
```

마이그레이션 도구는 코드를 `let mut` 구문, struct의 새로운 `public` 수식어,
그리고 `friend` 선언 대신 `public(package)` 함수 가시성을 사용하도록 업데이트합니다.

## `let mut`를 사용한 가변 바인딩

Move 2024는 가변 변수를 선언하기 위한 `let mut` 구문을 도입합니다. `let mut` 구문은
선언 후 변경할 수 있는 가변 변수를 선언하는 데 사용됩니다.

> `let mut` 선언은 이제 가변 변수에 필수입니다. `mut` 키워드 없이 변수를
> 재할당하려고 하면 컴파일러가 오류를 발생시킵니다.

```move
// Move 2020
let x: u64 = 10;
x = 20;

// Move 2024
let mut x: u64 = 10;
x = 20;
```

추가적으로 `mut` 키워드는 튜플 구조 분해와 함수 인자에서 가변 변수를 선언하는 데
사용됩니다.

```move
// 값으로 받아서 변경합니다
fun takes_by_value_and_mutates(mut v: Value): Value {
    v.field = 10;
    v
}

// `mut`는 변수 이름 앞에 위치해야 합니다
fun destruct() {
    let (x, y) = point::get_point();
    let (mut x, y) = point::get_point();
    let (mut x, mut y) = point::get_point();
}

// struct 언패킹에서
fun unpack() {
    let Point { x, mut y } = point::get_point();
    let Point { mut x, mut y } = point::get_point();
}
```

## Friend는 비권장됨

Move 2024에서 `friend` 키워드는 비권장됩니다. 대신 `public(package)`
가시성 수식어를 사용하여 같은 패키지의 다른 모듈에 함수를 표시할 수 있습니다.

```move
// Move 2020
friend book::friend_module;
public(friend) fun protected_function() {}

// Move 2024
public(package) fun protected_function_2024() {}
```

## Struct 가시성

Move 2024에서 struct는 가시성 수식어를 가집니다. 현재 사용 가능한 유일한 가시성 수식어는
`public`입니다.

```move
// Move 2020
struct Book {}

// Move 2024
public struct Book {}
```

## 메서드 구문

새 버전에서는 struct를 첫 번째 인자로 가지는 함수가 struct와 연결됩니다.
이는 함수를 점 표기법으로 호출할 수 있음을 의미합니다. 타입과 같은 모듈에 정의된
메서드는 자동으로 내보내집니다.

> 메서드는 타입이 메서드와 같은 모듈에 정의된 경우 자동으로 내보내집니다.
> 다른 모듈에 정의된 타입에 대한 메서드를 내보내는 것은 불가능합니다. 그러나
> 모듈 범위에서 메서드에 대한 [사용자 정의 별칭](#method-aliases)을 만들 수 있습니다.

```move
public fun count(c: &Counter): u64 { /* ... */ }

fun use_counter() {
    // move 2020
    let count = counter::count(&c);

    // move 2024
    let count = c.count();
}
```

## 내장 타입의 메서드

Move 2024에서는 일부 네이티브 및 표준 타입이 연관 메서드를 받았습니다. 예를 들어,
`vector` 타입은 벡터를 UTF8 문자열로 변환하는 `to_string` 메서드를 가집니다.

```move
fun aliases() {
    // 벡터를 문자열과 ascii 문자열로
    let str: String = b"Hello, World!".to_string();
    let ascii: ascii::String = b"Hello, World!".to_ascii_string();

    // 주소를 바이트로
    let bytes = @0xa11ce.to_bytes();
}
```

내장 별칭의 전체 목록은 [표준 라이브러리](./../move-basics/standard-library#source-code)와
[Sui 프레임워크](./../programmability/sui-framework#source-code) 소스 코드를 참조하세요.

## 차용 연산자

일부 내장 타입은 차용 연산자를 지원합니다. 차용 연산자는 지정된 인덱스에서
요소에 대한 참조를 얻는 데 사용됩니다. 차용 연산자는 `[]`로 정의됩니다.

```move
fun play_vec() {
    let v = vector[1,2,3,4];
    let first = &v[0];         // vector::borrow(v, 0) 호출
    let first_mut = &mut v[0]; // vector::borrow_mut(v, 0) 호출
    let first_copy = v[0];     // *vector::borrow(v, 0) 호출
}
```

차용 연산자를 지원하는 타입:

- `vector`
- `sui::vec_map::VecMap`
- `sui::table::Table`
- `sui::bag::Bag`
- `sui::object_table::ObjectTable`
- `sui::object_bag::ObjectBag`
- `sui::linked_table::LinkedTable`

사용자 정의 타입에 차용 연산자를 구현하려면 메서드에 `#[syntax(index)]`
속성을 추가해야 합니다.

```move
#[syntax(index)]
public fun borrow(c: &List<T>, key: String): &T { /* ... */ }

#[syntax(index)]
public fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }
```

## 메서드 별칭

Move 2024에서는 메서드를 타입과 연결할 수 있습니다. 별칭은 모듈에 로컬로 모든 타입에 대해
정의할 수 있거나, 타입이 같은 모듈에 정의된 경우 공개적으로 정의할 수 있습니다.

```move
// my_module.move
// 로컬: 타입이 모듈에 외부적입니다
use fun my_custom_function as vector.do_magic;

// sui-framework/kiosk/kiosk.move
// 내보내기: 타입이 같은 모듈에 정의되어 있습니다
public use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;
```

{/* ## Macros

Macros are introduced in Move 2024. And `assert!` is no longer a built-in function - Instead, it's a macro.

```move
// can be called as for!(0, 10, |i| call(i));
macro fun for($start: u64, $stop: u64, $body: |u64|) {
    let mut i = $start;
    let stop = $stop;
    while (i < stop) {
        $body(i);
        i = i + 1
    }
}
```
 */}
